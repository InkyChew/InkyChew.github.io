<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Becomegood Code World</title>
  
  <subtitle>Be a better self</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://InkyChew.github.io/"/>
  <updated>2021-05-25T10:16:56.636Z</updated>
  <id>https://InkyChew.github.io/</id>
  
  <author>
    <name>InkyChew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 30 days challenges</title>
    <link href="https://InkyChew.github.io/js-30challenge/"/>
    <id>https://InkyChew.github.io/js-30challenge/</id>
    <published>2021-05-25T10:14:00.000Z</published>
    <updated>2021-05-25T10:16:56.636Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javascript30.com/" target="_blank" rel="noopener">https://javascript30.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://javascript30.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://javascript30.com/&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="javaScript" scheme="https://InkyChew.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>資料庫優化 -  正規化與反正規化</title>
    <link href="https://InkyChew.github.io/db-normalization/"/>
    <id>https://InkyChew.github.io/db-normalization/</id>
    <published>2021-05-09T06:40:14.000Z</published>
    <updated>2021-05-10T04:57:05.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h1><p>將Table切分成多個，以減少儲存空間浪費，提升儲存效能(storage efficiency)</p><p><img src="https://lh3.googleusercontent.com/3iJwTXJNBUxM0Ip56m8qWpPCT9QoFUc9p3yUQ89m2AQeeycIUam-CwFfkrHl53M28p-SqcPeH4Uz7hXZu7FJnY06upb5tjm97Rm7ivoOxcT87d2T6NnOpjwKVoRyetwZN_nTp77k1_7TmViUnvg4T72kaY8RCMyiEEqRMuhAN-uH3hqakJ11zY2mLCDzjDDIFI9FAK1baW2H4D_IlTyFBa3kNboIJ0jk9DgUA_biYf0_VUQkDIsriGRCCjyIDD3B8w9DvSolulxiKfDkulVNFwJWbABBQ80RRmtfHFXDNa-ta4sqgAg-hWofvlRZX4kSjc9rYkmSDq7OwicoOJqmamTqfjcukEyEvo38XColpkrpyOGfUxSS9P6E8WkgONnu0gKVEkG72sELvqDH85S63iOkL7Go_5_Q3typVvCsNitDCHUsIF9MNHPlyuZgN76yRGRsMT86_OmEL26t0UNkH2Io4u235cbK5FeLxnKMShsyakwBjH7mHqJl-dKNiSnpvXnWvmAVY-uAgr1Azd29js15Xufs4xUxRZTlH16XmG775ikDySKgcvN6ZfAXusQWEFE5BOI72hCI7J3LNdIsOwucePwClsglEJrjXywPxfnk6wjNJmryrXqVajpQbiWURc3E34tRQY-bUbg1bSkTRR5uGs4IS2canRGhGidQuZkFTtIH9wz-RuEYf0lqxh9WJGkWU7eO_hUGntnaSH7zYQ=w1310-h937-no?authuser=1" alt="0NF"></p><a id="more"></a><h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><p>去除重複 (repeating fields)<br>每個欄位必須且只能包含一個值，不能是multi-valued, nested relations, null<br><img src="https://lh3.googleusercontent.com/rqZpDXmeBB80GU2pMgnubFFNkBmx5KGkyWL-cNBmS-XU7LT_9LlvCDo4xkXMubkYEOQ-JattfvoKz6eAN7gEU-JOBkoLLH38Ber_zU-2u2IuvKuOhdtQiem6glbd0C42C4EbUIIPuZOeU9EpiiCyrrtheYuSna2RrYlQsFlj47ezvzDbPsIwCIk8NTp4e_ReJznt5EY1llHBEHVgZ1aoUxJGI5P7wnqUuVdmgBIIjq0SdF3_P0-ZitREUjvxbhzmQkWJcTy__uR54KVKy2v-cRFmuvUeEyW6QJ1FrBw30HK2hlTLrBo6YQttJx1eqr5kqnIFdi-oh6s5eJrt075KCw7BHJyUDDsTvQkvKBuEcL569R1NKuI5HHohCCE6CVk6Q7-XbxNi0dyJLTZjskfLL67dqgUv7UCk8tOas4ZRx3yCrnWXNcGGZfUkVbJhdw_GQuLZIgzV4V531qXKrKp5Hf0zoO1y61Si1ptg5B7lIB_PQKSZgsL1gG1sx8dT9d6BwJipd6bagCHT-iFHJ1xAiPKq-1vDjfw3pAiecqyL0SZWKBjtVu_txKUIkgXCQlTvE1Qgnz4H01NPFD-MlatwVl5vA5AD7QpFjSCpZkxJO53aj6HSP5GJWmLH_Czi-a9xC74c_6ZwnyS4ObqLsBPQlSTAng6Sgkmqr4b5a-b82Bgn7pSDgt0c4EwQaeMfK1X_pTMX1zemK_NINeoB2wFfxA=w707-h231-no?authuser=1" alt="1NF"></p><h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><p>去除部分相依 (partial dependency)<br>所有非主鍵欄位能完全相依於所有主鍵，使主鍵成為whole primary key<br><img src="https://lh3.googleusercontent.com/IFOebURxHrafp3qkWxfNJsKrbHDJIQZnq4MliCmCCX91TJRzr6AzOwQrJ0bxKRMapcSp7D0BoyjM_zI_o9e-tD9uqRtQp_OGijJ314gcoginwW1fkTQXrr5W8U8ntQQpJryQI6kS2cyo7fAcp2_oGnXntJomG4wkh5Wyb-l211P9VrmvFSMjFwcc80DWK_OnR9q0mqQAGnc_ZR9Ux8Z4AglZ97h_KI67zlikD46GcRu1uV7zK6opbLlm_qgAYKyHQXeHQ1vkBuuyHu_arjwcS07aA39OlLqm1a1Ju_J-Z0eS6ut3rZFEs1lxYYGUo8W1PAfSQJcO21c7RN1fKtZD6sLU-RkByD8ybbDCexc3EW3hells9uJ4qEXmHz84Y1HtfbEPhm1qsi_opYk7BgXdrUieL4T8V-aa3y7HjAV5mKEevjUjgILsSsjiFJFbz-yoyLeygOYjuMY29aP022XHzotuWdjRdpLAY-Iy6hv6bkJ6d06cwtSTlW_s2CaxlFF57-m8p2BsvYT4NosUBo7AYaZIfhI_t2RIJrI3t1uXeklF5DOTZYcEC0htbids6GPGoMsVmL_5fj-cR3gZdRrO5Z2GKcrQseaYevmH6VPDA1VvZYCP0WMMkae5agRXgBK2lSKcpJ5U73Pjb2tWUNafhn5PwjMo8GUFwSBMqn7187jQ09mKJqxRaGUpZqiLdjM1_rUDU-8BDZkeolB7oFInlQ=w1451-h552-no?authuser=1" alt="2NF"></p><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><p>去除遞移關係 (transitive dependency)<br>所有非主鍵欄位只能透過主鍵得到<br>稅率(Tax Rate)必須透過州名(State)才能得到；State必須透過Order Number (PK)才能得到，此為遞移關係。<br><img src="https://lh3.googleusercontent.com/N06R5LElXLZgUqTVsFPn1huurB-ztAZD_vT7E-UXRNnohyJONfvc8HNsxAQO6HzBg2zSQzVFsQU6oBnqcywBS04ukM6QuaFMPQPNENOoh5zjtDcTzTS3TrudaT3I7WzF8VCXvNEpD_w6_Z8qELqkMHKTv1DLP_ezE-qLkWM1S2UR5gIniOKepmXBkjcAhfM_1DT_3scuPgy7muGA4SNxMFu51vReiN65WKg6wXkzqWWyBpQQk7S-A7A4qdUpUQLU7muYTJ80-J6FqAcfcCrXYLZ1rIiA8sIfktyeJGwXfASsiUC_6rSNLulSowfJL7CiXNJBfw-IvAmftc6v78KlbgGklDsTyBkH3azuP0REHLeC9RTAyzqD-dbpkgrTfwXoB7IXztRc2toCV0gT08GG1nyTOZ3H0TzMDeDN8z7Z57MN3qP2hO9UBCG4pAaMn6DDFgCZ83uH0JZizkVfDEeoUaMrDmMxVoUzSuzKkX58ZcxnnfVHaTzwc8r36s-CqblbZznZ1Ebt0RWLPdAWJ8LXxCqLAh6HF5l0IXrv71wW1glWeQcrqm_jtSqunCXlMTsKlANLur6fCdnUoXZUZeM9Vul0PribPOAQWhe2AkcXLBmSTsRKVrsWP-cS-s8jLkqlD_2AuepjgjcfbuGsvpwhgkhxPMNLxooEf3ZeiaJs0ETfENCir2w_7Hx8M55r_WhIDQZ0kI5rH7rsYMjaCrvnHg=w1920-h828-no?authuser=1" alt="3NF"></p><h1 id="Denormalization"><a href="#Denormalization" class="headerlink" title="Denormalization"></a>Denormalization</h1><p>將Table合併，以提高存取速度(speed up access)<br>當table A的資料被讀取時，常常需得到table B的資料，且此資料不須經常更新，即可將table B的資料加入table A中，以減少表格間的join，提高讀取速度。</p><p>當Order Table被讀取時，常常需得到Cust Table中Last Name的資料，即可將Cust Last Name加入Order Table中，以提高效能。</p><p>若兩Table為<code>1..1</code>的關係，可將兩Table合併<br>每筆訂單必有運送資訊，可將運送資訊加入訂單當中，提升效能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Normalization&quot;&gt;&lt;a href=&quot;#Normalization&quot; class=&quot;headerlink&quot; title=&quot;Normalization&quot;&gt;&lt;/a&gt;Normalization&lt;/h1&gt;&lt;p&gt;將Table切分成多個，以減少儲存空間浪費，提升儲存效能(storage efficiency)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/3iJwTXJNBUxM0Ip56m8qWpPCT9QoFUc9p3yUQ89m2AQeeycIUam-CwFfkrHl53M28p-SqcPeH4Uz7hXZu7FJnY06upb5tjm97Rm7ivoOxcT87d2T6NnOpjwKVoRyetwZN_nTp77k1_7TmViUnvg4T72kaY8RCMyiEEqRMuhAN-uH3hqakJ11zY2mLCDzjDDIFI9FAK1baW2H4D_IlTyFBa3kNboIJ0jk9DgUA_biYf0_VUQkDIsriGRCCjyIDD3B8w9DvSolulxiKfDkulVNFwJWbABBQ80RRmtfHFXDNa-ta4sqgAg-hWofvlRZX4kSjc9rYkmSDq7OwicoOJqmamTqfjcukEyEvo38XColpkrpyOGfUxSS9P6E8WkgONnu0gKVEkG72sELvqDH85S63iOkL7Go_5_Q3typVvCsNitDCHUsIF9MNHPlyuZgN76yRGRsMT86_OmEL26t0UNkH2Io4u235cbK5FeLxnKMShsyakwBjH7mHqJl-dKNiSnpvXnWvmAVY-uAgr1Azd29js15Xufs4xUxRZTlH16XmG775ikDySKgcvN6ZfAXusQWEFE5BOI72hCI7J3LNdIsOwucePwClsglEJrjXywPxfnk6wjNJmryrXqVajpQbiWURc3E34tRQY-bUbg1bSkTRR5uGs4IS2canRGhGidQuZkFTtIH9wz-RuEYf0lqxh9WJGkWU7eO_hUGntnaSH7zYQ=w1310-h937-no?authuser=1&quot; alt=&quot;0NF&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="https://InkyChew.github.io/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS Core Services - Storage</title>
    <link href="https://InkyChew.github.io/aws-storage/"/>
    <id>https://InkyChew.github.io/aws-storage/</id>
    <published>2021-04-24T16:29:31.000Z</published>
    <updated>2021-05-03T12:32:45.539Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fpKzXs_RasdvbDZSaXbG5M1qtLoExOeSO7dHwOuBtHHr4mNOwBPjNSaCU8rCxbv346FMxebVwli7kGvJZ4GnrYJ8C3JD7Yfv2F8HHGEPzrGgBGVSbdSAyWSCG_iEhrYSYnjtJh-9SkwOj3vGEJr3Y=w730-h405-no?authuser=1" alt></p><a id="more"></a><p><strong>Block storage V.S. Object storage</strong></p><ul><li>Block storage將資料儲存在一個個區塊(Block)中。當更改檔案中的某一個字元時，會找到該字元儲存的區塊進行修改，也就是說只修改檔案中的某一個區塊。</li><li>Object storage以Object為單位儲存。當更改檔案中的某一個字元時，會將整個檔案重新覆寫，修改整個檔案。一個檔案就是一個Object。</li></ul><h2 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h2><p>Elastic Block Storage，儲存方式為<strong>Block</strong> storage，提供<strong>一個</strong>EC2 Instance個別的儲存空間。</p><p><strong>Volume Types</strong><br><img src="https://lh3.googleusercontent.com/pw/ACtC-3cc43Pu0kNzM_PtjntUHvQ7nCEGKyJVfB_zYeoprqE4X8D3KU29sIMZmb-kGI7ZJNxWHUH7HjCOnxTf6LADFkgPIXDsCSt_JMtwlVj56DUpGubSVQc0KZjcBljoFLJy7FcZpAP-oVSI4b6Xn1sKdPs=w767-h361-no?authuser=1" alt><br><em>IOPS: Input Output Operations per Second</em></p><p><strong>Snapshots</strong><br>使用快照以建立一個新的EBS volume types</p><h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><p>Simple Storage Service，儲存方式為<strong>Object</strong> storage，可以無縫地立即地縮放資料，並可以觸發(trigger)事件。</p><p><strong>Storage Classes</strong></p><ol><li>Standard</li><li>Standard-IA</li><li>One Zone-IA</li><li>Glacier</li></ol><p><em>IA: Infrequence Access</em></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3d8uGcBLBem0M6suJwf8q8mKusfLr2ex4O9uoNGNId9E61L0EbBRnDD384OAMt1fRHl0MHyCc1egXQEta5bVFT4ktBDnYrAcNTEpfV8lhRoz0rFj2i0fFgxqie4xOM3h0fJLAEGQa_3zXyUbRM8lyg=w1606-h814-no?authuser=1" alt></p><p>在Region中建立一個<strong>獨一無二</strong>的Bucket name，並將資料上傳到這個Bucket當中，AWS會自動備份資料到三個不同的Availability zone。</p><h3 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h3><p>提供典藏的(有價值不能丟需要保存很久的)資料儲存的服務，安全可靠且低成本。</p><p><strong>Lifecycle policies</strong><br>隨著時間移動資料到成本低的儲存類別<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3dex0TE_pd9S5K_FGi3zQWcMCmwZ6KorgVJiZBULgO7AvHP0nWmsOZ1Jh4xoXonjTQsMx1hx227AcrUQRSgJ_jCMK5y-0ViA0U6rPHu_FwEpYuDopo5qfvARnS8xDrGiyX9E305QIs10AqxQdotZJo=w839-h259-no?authuser=1" alt></p><h2 id="EFS"><a href="#EFS" class="headerlink" title="EFS"></a>EFS</h2><p>Elastic File System，儲存方式為<strong>File</strong> storage。儲存的資料可以共享，可提供<strong>多個</strong>EC2 Instances存取。</p><p><em>EBS 在建立 Volume後必須選擇 File system. ex: Linux, Windows…</em><br><img src="https://lh3.googleusercontent.com/pw/ACtC-3cRyzR58SqVZb-YuOy8jyfQ9DOPThMigeHGYN0A-mozNwPy0ailoPMY9L_leTEFTyUnjtDRfFRe6DCX9Lv9ygPm0dza6eYh1SZ5G3ucSqaJDlZd74EwNgMGDMWXRo_TWaitAmZgzErLlYupUhoAyDw=w1513-h788-no?authuser=1" alt></p><p><strong>Mount target</strong><br>一個File system可以有多個Mount target，存在於同一個VPC中，且一個Subnet與一個Avaliability zone中只存在一個Mount target。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3fpKzXs_RasdvbDZSaXbG5M1qtLoExOeSO7dHwOuBtHHr4mNOwBPjNSaCU8rCxbv346FMxebVwli7kGvJZ4GnrYJ8C3JD7Yfv2F8HHGEPzrGgBGVSbdSAyWSCG_iEhrYSYnjtJh-9SkwOj3vGEJr3Y=w730-h405-no?authuser=1&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="AWS" scheme="https://InkyChew.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS Core Services - Network</title>
    <link href="https://InkyChew.github.io/aws-network/"/>
    <id>https://InkyChew.github.io/aws-network/</id>
    <published>2021-04-23T16:25:46.000Z</published>
    <updated>2021-05-03T12:41:21.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h2><p><strong>Virtual Private Network</strong>，必定架構在一個Region當中，一個帳戶可以擁有多個VPC，多個VPC之間彼此獨立。透過<strong>Subnet</strong>切割VPC，以允許VPC跨越多個Availability Zone。</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fqMU_ZKbHeQQs4JYZzS7JY-YSWSVBKjOnslAXywabnzed_dPjlk2erVO_DzlBDPkpQMYhzjP4rxwVGq_37Lzvxacv33LLClHIAUdNxaiGo75QwEY8Co5--XegNpFS3fyeoXKYgInHaPKbHJl00mfo=w1008-h784-no?authuser=1" height="400px"><a id="more"></a><h3 id="Network-configuration"><a href="#Network-configuration" class="headerlink" title="Network configuration"></a>Network configuration</h3><ol><li><p><strong>IP address range</strong><br>每一個VPC都有一個特定的IPv4位址(32bit)。ex: 10.0.0.0/<code>x</code> (16&lt;=x&lt;=28 bit)<br><code>/16</code> 32-16=16，有2<sup>16</sup>個IP位址可使用<br><code>/20</code> 32-20=12，有2<sup>12</sup>個IP位址可使用<br><code>/28</code> 32-28=4，有2<sup>4</sup>個IP位址可使用</p><ul><li>EIP (Elastic IP) Address: 將一個EIP Address與一個EC2 Instance連結(綁在一起)，VPC(為Private IP)即可使用此<strong>Public</strong> IP address對<strong>外</strong>連接。</li></ul></li><li><p><strong>Subnet</strong><br>切割VPC的IP address range。ex: 10.0.0.0/20 (default)</p><ul><li>一個Availability zone當中可以有多個Subnets。也就是，一個Subnet對應一個Avaliability Zone，但不可以橫跨Availability Zone。</li><li>Types<ul><li>public : 透過Internet的連接使Subnet彼此互相連通</li><li>private : Subnet彼此不互相連通</li><li>VPN only (Virtual Private Network) : 完全只使用公司內部的網路連接</li></ul></li></ul></li><li><p><strong>Route table</strong><br>控制<strong>流出</strong>Subnet的流量，控制Subnet的流向。ex: 禁止Subnet通往Internet。</p></li><li><p><strong>Network gateway</strong></p><ul><li>IGW (Internet Gateway) : 允許VPC與Internet連接。讓外面的Network透過Internet連進VPC，讓外面連進來。</li><li>NAT (Network Address Translation) Instances &amp; Gateway<br>不想讓外面連進來，但想連出去，透過NAT將Private轉成Public。<br>由自己管理的服務稱為Instances，由AWS管理的服務的稱為Gateway。</li><li>Endpoint<br>當不想使用IGE或NAT時，可以使用Endpoint<strong>直接</strong>與AWS的服務連接。</li><li>Peering<br>允許兩個不同Region的<strong>VPC</strong>互相連接。</li></ul></li><li><p><strong>Security</strong></p><ul><li>Security groups : EC2 Instances的虛擬防火牆，有狀態的</li><li>ACLs (Network Access Control Lists) : Subnets的防火牆，控制<strong>Sebnet</strong>的存取，無狀態的</li></ul></li></ol><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ol><li>Hardware VPN</li><li>Direct Connect : 專用的私有連接</li><li>VPN CloudHub : 透過VPC，與多個VPN連接，多個VPN彼此可以互相連通。</li><li>Software VPN</li></ol><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cfmTFn-A03ftAqKRhxPsL01MD3HcpY2EKHmOPVXBja26-_eOs_7IK7Fj_RCrhhIhoh7snFhFIAxQklTz30aZMXSflFMlS1epXpjwlX-SKfL8dM0ju-4qqpQYdVGi1dDi_9qIEKoXRGCRKtxUGZdys=w1427-h881-no?authuser=1" alt></p><h2 id="Security-groups"><a href="#Security-groups" class="headerlink" title="Security groups"></a>Security groups</h2><p>Security groups是一個虛擬的防火牆(virtual firewall)。一個Security group可以有多個EC2 Instances，也就是說，多個EC2 Instances可以共用一個防火牆的設定。Security group可以跨Subnets，不同的Subnets中的EC2 Instances可以共用同一個防火牆設定。</p><p><strong>Key pairs</strong>為從Firewall外部連接進來時，加解密login資訊的密碼學技術。<br><em>Linux : SSH<br>Windows : RDP (Remote Desktop)</em></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3f-LgoPA-dLBkhPm6O0Sb12hV8Utt3En2Y1RsXS1VIDxu6uS_37m8SP6Cpytkf7-Ad17E7tonu2ndKkf9P2QmFlS9A2jQVdBjq-aWErmosv2G74G9-dgRZk6YkMBel1Zsau6tawboyMWjAaQeL30_U=w1735-h804-no?authuser=1" alt></p><h2 id="Cloud-Front"><a href="#Cloud-Front" class="headerlink" title="Cloud Front"></a>Cloud Front</h2><p>連線先後順序 : Edge Location &lt; Edge Location Cache &lt; VPC<br>若先前連線的位置<strong>有</strong>資源時，即取得；若<strong>無</strong>資源，則從後一個位置取得資源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VPC&quot;&gt;&lt;a href=&quot;#VPC&quot; class=&quot;headerlink&quot; title=&quot;VPC&quot;&gt;&lt;/a&gt;VPC&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Virtual Private Network&lt;/strong&gt;，必定架構在一個Region當中，一個帳戶可以擁有多個VPC，多個VPC之間彼此獨立。透過&lt;strong&gt;Subnet&lt;/strong&gt;切割VPC，以允許VPC跨越多個Availability Zone。&lt;/p&gt;
&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3fqMU_ZKbHeQQs4JYZzS7JY-YSWSVBKjOnslAXywabnzed_dPjlk2erVO_DzlBDPkpQMYhzjP4rxwVGq_37Lzvxacv33LLClHIAUdNxaiGo75QwEY8Co5--XegNpFS3fyeoXKYgInHaPKbHJl00mfo=w1008-h784-no?authuser=1&quot; height=&quot;400px&quot;&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="AWS" scheme="https://InkyChew.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS Core Services - Compute</title>
    <link href="https://InkyChew.github.io/aws-compute/"/>
    <id>https://InkyChew.github.io/aws-compute/</id>
    <published>2021-04-22T16:25:35.000Z</published>
    <updated>2021-05-03T12:37:56.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h2><p>Elastic Compute Cloud，在雲端上提供虛擬的<strong>Computing環境</strong>。此虛擬環境稱為<strong>Instances</strong>。</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eEtAVK-hrYk1yYfAJpa2xJCbjRNsgeHWZmb34BFxZZx2PdBAAUWWXU6aFjDe21-o7sttqPhyIlJtyPYtZlq2U9n-40OtpbO7ApxXn0pFg9NSv85eoddvWS2w7wy1qsmX3MRoOuKWAVAO4zzlaJL8o=w716-h159-no?authuser=1" alt><br>依照對資源不同的需求區分成四種方案:</p><ol><li><p>On-Demand<br>適合短期的、高峰的或不可預測的工作量，例如應用程式的測試與開發。成本高(3)，資源最少要使用60秒。</p></li><li><p>Spot Instances<br>Amazon釋出閒置資源，讓顧客以競標的方式取得，因此取得資源的成本低(1)。但是資源有隨時被Amazon收回的風險，適合起始與結束時間彈性的應用。透過<strong>Hibernation</strong>在資源被取回時暫時休眠，並在取回資源時重啟Instances。</p></li><li><p>Reserved Instance<br>向Amazon預定1年或3年的資源，成本較低(2)。適合清楚資源需求的應用或災難發生時的預備資源。</p></li><li><p>Dedicated Host<br>向Amazon取得一台專用的主機，以遵守商業、政府的規定。</p></li></ol><a id="more"></a><p><strong>Cost optimization</strong></p><ol><li>Right sizing<br>選擇適合的Instance type，並透過CloudWatch監管以衡量流量，縮減Instances的數量。</li><li>Reserved Instances</li><li>Increase elasticity<br>使用<strong>流量小</strong>的Instances，可以增加彈性。由下圖可以了解，流量大的Instances會在需求不多時造成浪費。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3cAwJVZNuTczTNyX5P37ee9t03GJlKHeA6jFmupMp6cLE_yHLuh0xTklqvaK1EMxic_QOfBcRP937l_8lOc9cW3NZtAkP95GuZIr3LoilV2B3UH800TZdBUKXsO2FoQ1nyls_2b9hlsLXpZL4Rt6wo=w727-h333-no?authuser=1" alt></li><li>Monitor &amp; Improve</li></ol><h3 id="AMI"><a href="#AMI" class="headerlink" title="AMI"></a>AMI</h3><p>Amazon Machine Image，為<strong>初始化</strong>Instance的<strong>軟體</strong>。當Instance啟用的時候，AMI將佈署使用EC2提供的服務並定義作業系統，修補程式的初始狀態和應用/系統軟體。</p><p>AMI lifecycle and uses<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3dO97xoSYoBPepPKcppD_ql8fnCWUxp7D8Bd1RF2QG2ywB2YMmuKrIJhZvWIyJhXp-KGkm4tWF097gyKsCWafnWcHVtHp933WmKtVnbaYyYAD1YrR0zh9-4pCFa3extZwu8skwb3dTJ4pJGnmy9918=w494-h213-no?authuser=1" alt="AMI lifecycle and uses"></p><h3 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h3><p>Elastic Load Balancer (Balancing)，可以做為流量流入的單一窗口(single access point)，分散<strong>進入</strong>EC2 Instances的流量以提高容錯程度(fault tolerance)與可用性(availability)，增加彈性與可擴充性，且可以decouple application environement。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3dJ14hYvkHn-_C4-CeDVB3vxVqjs6B8PYvbMNgT4bKwEdSrlm1ZnacGFJFm9cFSbo_ZdEPbLJ3g0fJcz8H1bbVgryDf1Pn_OcaECD2s1yMhQKjPNb05--xs8KeVy4U93k9sKi3peg_jVcbNRrALXd0=w484-h228-no?authuser=1" alt><br>Type:</p><ol><li>ALB (Application Load Balancer)<br>掌管應用層(HTTP, HTTPs)的流量。<ul><li>routing<ul><li>path-based </li></ul></li></ul></li></ol><p><em><a href="https://webapp.yuntech.edu.tw/`YunTechSSO`" target="_blank" rel="noopener">https://webapp.yuntech.edu.tw/`YunTechSSO`</a></em><br><em><a href="https://webapp.yuntech.edu.tw/`WebNewCAS`" target="_blank" rel="noopener">https://webapp.yuntech.edu.tw/`WebNewCAS`</a></em><br>        - host-based<br><em>https://<code>webapp</code>.yuntech.edu.tw/</em><br><em>https://<code>webmail</code>.yuntech.edu.tw/</em><br>    - Dynamic port: 若有多個相同的port，會動態分配流量至閒置的port中。</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cVRPairgPNakuN2yopJmkKj1kJ9eDC93ucRVa0pAkIwrhgJHvQdGazpdFSjS5XJIv3nSFChVhcIo0HsftJq38WHh84pP4z-wMa-bhDSbACpBY6h5O41GbDfYkqv5wzXnM0PpzIt1ky4Y2z7nQI34E=w1520-h652-no?authuser=1" alt></p><ol start="2"><li>NLB (Network Load Balancer)<br>掌管傳輸層(TCP)的流量，分派速度快，適合在立即與變化快速的流量模式下使用。NLB可以跨AZ，每一個AZ會有一個static IP address。</li></ol><h3 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h3><p>依照需求啟動/終止EC2 Instances，以調整EC2 Instances的數量，並自動地向ELB登記。當增加/減少EC2 Instances時，ELB必須知道，如此ELB才能正確的分派流量給各個Instances。</p><p><em>可以Scaling的資源包含: EC2 Instances、Spot Fleets、DynamoDB tables indexes、Aurora replicas</em><br><em>Spot Fleets (競標艦隊): spot + on-demand</em></p><p><strong>Components</strong><br>以EC2 Instances為例<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3el49Nc3JvKHp4GOWbo2L2W2iFWPwCKq0Nb5MnTwZc9LuZrLGW7fuC8XNEIIAdUhQ8S4eRjJbeN0C3TX8VzpurSDeMpPvVYA-1gtzwhRuYmgQUOXh0W6BNW3vIRS6jK6rkje4rT4PVLTsQjRcnWadk=w816-h393-no?authuser=1" alt><br><img src="https://lh3.googleusercontent.com/pw/ACtC-3cETQL37Bsbh7kL9b4tzrBSvK2aInfCKy9WFHh_0TLGmihdvUji062rQR8DYeHzit-nWsnPHnnbEFL6f8iPaVdsvaf9H6oFQ7GAySkwmuHzJwbfQo6DxDLoRTClO9CeZjeFAXxKPujLinprs5KWIQg=w863-h408-no?authuser=1" alt></p><h3 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h3><ul><li>用來追蹤資源的效能，監控EC2 Instances的流量。</li><li>蒐集log files加以分析做為資源方案選擇，條件設定時的依據。</li><li>當條件被觸發時透過alarm/event的通知採取行動。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3f78rryRd3yTIU-9bq-IVxzYdY8pMAIaO71SIByCds9jm5tIs72rpDdGtJHrXs1mbsTcdAyfQTRQxek1ebdY9ek7amL6-zGWQf9JDo9WpdV9QVHc74tCe9XU3Bnvl1ZIixApgySPjR9A5y8zKcQRXo=w720-h384-no?authuser=1" alt></li></ul><p><strong>ELB、CloudWatch、Auto Scaling 間的關係與互動</strong><br>Cloud watch蒐集流量資料加以衡量，達到特定條件出發alarm啟動Auto Scaling以增減EC2 Instances，並告知ELB，EC2 Instances的增減變化。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3foA4dsZgoDuRcpEZiKLpqbMvQJliMnL3wr148tE_ul-VMmyzEle-qEcese1zYGt-4p_CGdkjKtQAIlH78d6Qnw8Tmnff7e3C5ZmoIE8AqJBRBotRpH5Vm6UcRZlmcRiLdp_STsKoTFC3Odln5cpzw=w1393-h817-no?authuser=1" alt></p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>完全不須管理伺服器，以0.1秒計價，執行時間不得超過5分鐘。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3eELQBnYnlRdSt0Qvgijk1_Oful4_8oCCb8TizUTdZKORheaL4RqkKhzXt-W_ZN3LhdQQAtmecr4oL1OquM27mFik9KLPnNGFW1KlwBQis-BZM2cRgwsDrtBGo6Qv8XeOupFhETFey-MImr4lLCa7Q=w969-h337-no?authuser=1" alt></p><h2 id="Elastic-Beanstalk"><a href="#Elastic-Beanstalk" class="headerlink" title="Elastic Beanstalk"></a>Elastic Beanstalk</h2><p>Platform as a Service，快速佈署、縮放、管理 web apps。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3e22_nzJhBZ4Pd7-C8rAWGrZaxTzu-g1iegETBzeypyfKlZMta5AFR1XGTGtdniK2GubazLEH6zZvQPQ31e4zFnvh_39X870teUSlV-bBorQ4-7gXWmQUwB0mhcnvdzOtdiIGZH_wgVl7496XvAIDc=w708-h331-no?authuser=1" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EC2&quot;&gt;&lt;a href=&quot;#EC2&quot; class=&quot;headerlink&quot; title=&quot;EC2&quot;&gt;&lt;/a&gt;EC2&lt;/h2&gt;&lt;p&gt;Elastic Compute Cloud，在雲端上提供虛擬的&lt;strong&gt;Computing環境&lt;/strong&gt;。此虛擬環境稱為&lt;strong&gt;Instances&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3eEtAVK-hrYk1yYfAJpa2xJCbjRNsgeHWZmb34BFxZZx2PdBAAUWWXU6aFjDe21-o7sttqPhyIlJtyPYtZlq2U9n-40OtpbO7ApxXn0pFg9NSv85eoddvWS2w7wy1qsmX3MRoOuKWAVAO4zzlaJL8o=w716-h159-no?authuser=1&quot; alt&gt;&lt;br&gt;依照對資源不同的需求區分成四種方案:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;On-Demand&lt;br&gt;適合短期的、高峰的或不可預測的工作量，例如應用程式的測試與開發。成本高(3)，資源最少要使用60秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Spot Instances&lt;br&gt;Amazon釋出閒置資源，讓顧客以競標的方式取得，因此取得資源的成本低(1)。但是資源有隨時被Amazon收回的風險，適合起始與結束時間彈性的應用。透過&lt;strong&gt;Hibernation&lt;/strong&gt;在資源被取回時暫時休眠，並在取回資源時重啟Instances。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reserved Instance&lt;br&gt;向Amazon預定1年或3年的資源，成本較低(2)。適合清楚資源需求的應用或災難發生時的預備資源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dedicated Host&lt;br&gt;向Amazon取得一台專用的主機，以遵守商業、政府的規定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="AWS" scheme="https://InkyChew.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Cloud computing</title>
    <link href="https://InkyChew.github.io/cloudComputing/"/>
    <id>https://InkyChew.github.io/cloudComputing/</id>
    <published>2021-04-21T16:21:09.000Z</published>
    <updated>2021-04-24T16:34:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>Cloud computing是可以<strong>根據需求</strong>使用資訊科技服務的能力<br>根據NIST(National Institute of Standards and Technology)的定義，<strong>Cloud computing</strong>必須符合下列5項條件:</p><ol><li>On-demand self-serviced<br>可以根據需求自行取用服務。</li><li>Broad network access<br>資源與服務可得的範圍很廣。</li><li>Resource pooling<br>資源必須獨立區隔。例如公司A不能看到且不能存取公司B的資料，公司B也不能看到且不能存取公司A的資料。</li><li>Rapid elasticity<br>可以立即增加或減少資源。</li><li>Measured service<br>可衡量資源使用量(capacity)與提供資源的表現。</li></ol><a id="more"></a><h2 id="Delivery-Models"><a href="#Delivery-Models" class="headerlink" title="Delivery Models"></a>Delivery Models</h2><p>NIST依照<u>服務如何被使用</u>也就是<u>使用者需要與多少層級的基礎計算服務互動</u>定義3種cloud service <strong>Delivery Models</strong>:</p><ol><li>IaaS (Infrastructure as a Service)<br>當需要符合特殊的政府、行業<strong>規定</strong>，或需要<strong>控制</strong>環境的各方面時使用。ex: virtual machine instances, block storage, virtual private network segments, virtual function network device (router, firewall…)</li><li>PaaS (Platform as a Service)<br>降低基礎設備的維護與複雜性。ex: database, email…</li><li>SaaS (Software as a Service)<br>ex: web browser, mobile, IoT applications</li></ol><p><img src="https://i.imgur.com/eUNls2C.png" alt></p><h3 id="Shared-responsibility-model"><a href="#Shared-responsibility-model" class="headerlink" title="Shared responsibility model"></a>Shared responsibility model</h3><p>區分provider與consumer間的責任<br><img src="https://i.imgur.com/aQlX6oP.png" alt></p><h2 id="Deployment-types"><a href="#Deployment-types" class="headerlink" title="Deployment types"></a>Deployment types</h2><p>Cloud <strong>Deployment types</strong>:</p><ol><li>Public</li><li>Private<br>可以自行架設或供應商提供組織內部自用的雲端環境，以遵守特殊的政府或行業規定。</li><li>Hybrid<br>public + private</li><li>Community<br>在特定社群中共享資源，多用在學術、政府、開源專案。</li></ol><p><img src="https://i.imgur.com/hqe1FAv.png" alt></p><p>不同的Service Delivery Models可以源自不同的Deployment types，但必須符合Essential characteristics才能被視為Cloud computing。</p><p>在市場我們交易有形的產品或無形的服務，Cloud即為市場上的服務，可以大致區分成2種方案:</p><ol><li><strong>rental</strong> on-demand 短租<br>短期且需求有較高的不確定性時使用的方案</li><li><strong>leasing</strong> reserved 長租<br>長期且了解需求量時使用的方案</li></ol><h2 id="Virtualization-and-Containers"><a href="#Virtualization-and-Containers" class="headerlink" title="Virtualization and Containers"></a>Virtualization and Containers</h2><p>Cloud computing高度仰賴<strong>Resource pooling</strong>，但現實中實體可得的硬體為一個大單位，因此必須透過<strong>Virtualization</strong>將一個硬體切割成多個邏輯單位，以<strong>獨立</strong>地提供不同的個別使用者在同一個資源上使用。因此我們說Virtualization是驅動Cloud computing的引擎。</p><p>一個virtual machine一定會有一個<u>作業系統</u>，透過<strong>Hypervisor</strong>區隔多個作業系統(多個<u>tenants</u>個別使用者)，且每一個作業系統會確保只有該tenants有對virtual machine instances內容的存取權。</p><p><strong>Containers</strong>的概念與Virtualization相同，只是Containers比較<strong>小</strong>比較<strong>精實</strong>。Containers是一個package，包含一個application與其依賴的dependencies和configurations，但不包含作業系統。Containers並不包含作業系統，而是作業系統包含Containers，並透過<strong>Container engine</strong> (Manager)區隔多個Containers (App)。Containers間彼此獨立，但可以共享作業系統中的所有資源。</p><p><img src="https://i.imgur.com/j6zAsJ2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cloud computing是可以&lt;strong&gt;根據需求&lt;/strong&gt;使用資訊科技服務的能力&lt;br&gt;根據NIST(National Institute of Standards and Technology)的定義，&lt;strong&gt;Cloud computing&lt;/strong&gt;必須符合下列5項條件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;On-demand self-serviced&lt;br&gt;可以根據需求自行取用服務。&lt;/li&gt;
&lt;li&gt;Broad network access&lt;br&gt;資源與服務可得的範圍很廣。&lt;/li&gt;
&lt;li&gt;Resource pooling&lt;br&gt;資源必須獨立區隔。例如公司A不能看到且不能存取公司B的資料，公司B也不能看到且不能存取公司A的資料。&lt;/li&gt;
&lt;li&gt;Rapid elasticity&lt;br&gt;可以立即增加或減少資源。&lt;/li&gt;
&lt;li&gt;Measured service&lt;br&gt;可衡量資源使用量(capacity)與提供資源的表現。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="AWS" scheme="https://InkyChew.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure - Graph &amp; Network</title>
    <link href="https://InkyChew.github.io/ds-graph/"/>
    <id>https://InkyChew.github.io/ds-graph/</id>
    <published>2021-02-05T09:18:32.000Z</published>
    <updated>2021-05-03T12:22:15.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><p>圖形(Graph)由<strong>頂點(Vertics/Nodes)集合</strong>與<strong>邊(Edges)集合</strong>組成。<code>G=(V,E)</code><br>透過<strong>頂點</strong>儲存資料，透過<strong>邊</strong>表示頂點間的連通關係，依照有無方向性區分成<code>&lt;有向圖&gt;</code>與<code>(無向圖)</code>。  </p><p>完全圖: 圖形中的每一個頂點皆與其他頂點相互連接。<br>無向完全圖: |E| = N(N-1) / 2<br>有向完全圖: |E| = N(N-1)</p><div class="columns is-multiline">  <div class="column is-half is-12-mobile">  有向圖 (Directed Graph)  <img src="https://lh3.googleusercontent.com/pw/ACtC-3ff0Krpy5cP31zknom7aYMXzkPdggWKUJb2LG-F8AlFqgLJGtXYhPZNC9EnDwqF35BxEaRrE0w7XiN14lP_9FBoVUgd31a7y9OHhNbG4xRMbgkxzgGW0pWMRAIBGhMeweIIh-JprIgTs_zL7E1NdCo=w397-h346-no?authuser=1">  </div>  <div class="column is-half is-12-mobile">  無向圖 (Undirected Graph)  <img src="https://lh3.googleusercontent.com/pw/ACtC-3e5kKo4WxDXdAyfpezVx07IRyRMhPv_Ph6m8A7sxyOuGbHXsxM7_r0Aqjcfo2cWx08R37y7xmjH_gXC8qvSnMsAM0Dx47pEH1ahz6wtyL0uCAy6x-tMn22lk0948NHnAaXT8F1AbfKVDKzJ9u8kwoc=w397-h346-no?authuser=1">  </div></div><a id="more"></a><h2 id="分支度-Degree"><a href="#分支度-Degree" class="headerlink" title="分支度 (Degree)"></a>分支度 (Degree)</h2><ul><li><p>有向圖</p><ul><li>出分支度 (Out Degree) - 從該頂點指出去的箭頭數</li><li>入分支度 (In Degree) - 指向該頂點的箭頭數  </li></ul><table><thead><tr><th align="center">頂點</th><th align="center">出分支度</th><th align="center">入分支度</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>無向圖</p><table><thead><tr><th align="center">頂點</th><th align="center">分支度</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">3</td></tr></tbody></table></li></ul><h2 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h2><h3 id="相鄰矩陣-Adjacent-Matrix"><a href="#相鄰矩陣-Adjacent-Matrix" class="headerlink" title="相鄰矩陣 (Adjacent Matrix)"></a>相鄰矩陣 (Adjacent Matrix)</h3><p>若兩頂點互相連通則標示為<code>1</code>，否則標示為<code>0</code>。</p><div class="columns is-multiline">  <div class="column is-half is-12-mobile">    有向圖    <img src="https://lh3.googleusercontent.com/pw/ACtC-3dsMsv6Au1bKBdyxQMMFYGO1lHWNm5kKJ7Zc_GaE346sNKEsapz3eUQ2Nlm8EGerR6sDgLtaK45QYYquTor_19n7sblWfe9bkeKtlg232atkz9KLcxrO65n30pW_GpsvaAhPqoUi-CQ8RJKe_syQzY=w482-h321-no?authuser=1">    <ul>      <li>        出分支度為列的總和      </li>      <li>        入分支度為行的總和      </li>    </ul>  </div>  <div class="column is-half is-12-mobile">    無向圖    <img src="https://lh3.googleusercontent.com/pw/ACtC-3eGcgODOxHrY-Pb1Q5_PgP6lLPaBZdOJpk5H-ubtgquvchOK4wJ7wDbIRr-R1aUpIkBWF4XwQnWYsLgSxemXKJMIOa0aXfwQ4cRC2T2S39yBAKovlmE2AAiFib_pA8DFpUADDgVITq2URZRvU5rnt0=w457-h325-no?authuser=1" height="258">    <ul>      <li>        此矩陣為一<b>對稱矩陣</b>，透過對稱矩陣中上或下三角形的部分即可表示無向圖。      </li>      <li>        分支度為列/行的總和      </li>    </ul>  </div></div><h3 id="相鄰串列-Adjacent-List"><a href="#相鄰串列-Adjacent-List" class="headerlink" title="相鄰串列 (Adjacent List)"></a>相鄰串列 (Adjacent List)</h3><p>在相鄰串列中的一節點(node)包含頂點欄(Vertex Field)與鏈結欄(Link Field)。　　<br>Vertex Field - 儲存非零元素的行值(頂點)<br>Link Field - 指向同一列右邊非零元素的節點</p><div class="columns is-multiline">  <div class="column is-half is-12-mobile">    有向圖    <img src="https://lh3.googleusercontent.com/pw/ACtC-3cii110oS_ijL44mHJLL2bk6jQjOAH8KDkdAz7XpmT3-cNjD2CBv664V2iTXtPvzBGvLcWzMAWUUL_nhVNPfxHmrsIfAgHq3WTi9Ky0yzYblsB_4sUAKMlfdJEuAHgwu86iIB4m9MjHHs-Fno5V7_I=w632-h354-no?authuser=1">    有向圖的相鄰串列表示某一頂點<b>向外</b>連接其他頂點的關係    <ul>      <li>        出分支度為相鄰串列的長度      </li>      <li>        入分支度為<b>反向</b>相鄰串列的長度      </li>    </ul>  </div>  <div class="column is-half is-12-mobile">    <a href="https://onlinegdb.com/Bk9pGWKgO" target="_blank" rel="noopener">無向圖</a>    <img src="https://lh3.googleusercontent.com/pw/ACtC-3fVcPt2zT0zT3oxyJKUhvQQVesVc_uFN9vlbWBXDkeZ8g97xOIGqW1FBNDRA9ugq4X78tuF35FbBMXmlL5_hTJW-IsDS6gtmz7X4vn_L14lpqs3A9PrtxlLyt-CYlcM3m8C_HGBqRaDwBemhv9CAfY=w481-h354-no?authuser=1">    <ul>      <li>        分支度為串列長度      </li>    </ul>  </div></div><h2 id="圖形追蹤"><a href="#圖形追蹤" class="headerlink" title="圖形追蹤"></a>圖形追蹤</h2><p>從某一頂點開始，尋訪其他所有可到達的頂點</p><p>方法:</p><ol><li><p><a href="https://onlinegdb.com/H1sCbTDeO" target="_blank" rel="noopener">深度優先搜尋法 DFS</a><br>堆疊<br>Ⅰ 將起始頂點設定為拜訪過，並輸出該頂點<br>Ⅱ 選擇一<strong>與該起始頂點相鄰且尚未拜訪過</strong>的頂點<br>Ⅲ 將該選擇頂點當成起始頂點重複搜尋直到所有頂點皆被拜訪過為止</p><p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> j;</span><br><span class="line">  <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;</span><br><span class="line">  </span><br><span class="line">  visit[i] = visited;</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"step%d: visit v%d\n"</span>, ++step, i);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;vertices; j++)</span><br><span class="line">      <span class="hljs-keyword">if</span>(adj_matrix[i][j]==<span class="hljs-number">1</span> &amp;&amp; visit[j]!=visited)</span><br><span class="line">          dfs(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><a href="https://onlinegdb.com/Bk1a9pDxO" target="_blank" rel="noopener">廣度優先搜尋法 BFS</a><br>佇列<br>Ⅰ 將起始頂點設定為拜訪過，並輸出該頂點<br>Ⅱ 將<strong>所有</strong>與該起始頂點相鄰且尚未拜訪過的頂點<strong>加入queue的尾端</strong><br>Ⅲ 當queue不為空，取出<strong>queue最前端</strong>且尚未拜訪過的頂點<br>Ⅳ 將該取出頂點當成起始頂點重複搜尋直到所有頂點皆被拜訪過為止</p><p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> j;</span><br><span class="line">  <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;</span><br><span class="line">  </span><br><span class="line">  visit[i] = visited;</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"step%d: visit v%d\n"</span>, ++step, i);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;vertices; j++) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span>(adj_matrix[i][j]==<span class="hljs-number">1</span> &amp;&amp; visit[j]!=<span class="hljs-number">1</span>)</span><br><span class="line">          input_queue(j); <span class="hljs-comment">// 將頂點加入queue的尾端</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">while</span>(rear != front) &#123; <span class="hljs-comment">// queue is not empty</span></span><br><span class="line">      i = output_queue(); <span class="hljs-comment">// 取出最前端的queue</span></span><br><span class="line">      <span class="hljs-keyword">if</span>(visit[i] != visited)</span><br><span class="line">          bfs(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="擴張樹-Spanning-Tree"><a href="#擴張樹-Spanning-Tree" class="headerlink" title="擴張樹 (Spanning Tree)"></a>擴張樹 (Spanning Tree)</h2><p>基本特性:</p><ol><li>不允許迴路(Cycle)存在</li><li>必有一條路徑連接任兩頂點</li><li><code>|E| = |V| - 1</code><br>擴張樹的邊 = 頂點數 - 1</li></ol><hr><h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><p>網路(Netework)為在<strong>邊(Edge)</strong>上加上<strong>成本/權重(weight)</strong>的圖形。依照有無方向性區分成有向網路與無向網路。</p><h2 id="花費最小成本擴張樹"><a href="#花費最小成本擴張樹" class="headerlink" title="花費最小成本擴張樹"></a>花費最小成本擴張樹</h2><p>花費最小成本擴張樹(Minimum Cost Spanning Tree)為擁有<strong>最小邊集合總成本</strong>的擴張樹，但兩頂點間的成本不一定是最小的。<br>建立方法:</p><ol><li>Prim’s Method - 循序加入頂點</li><li><a href="https://onlinegdb.com/RcxGPp2ZQ" target="_blank" rel="noopener">Kruskal’s Method</a> - 循序加入邊</li></ol><h2 id="單一頂點到其他頂點之最短距離"><a href="#單一頂點到其他頂點之最短距離" class="headerlink" title="單一頂點到其他頂點之最短距離"></a>單一頂點到其他頂點之最短距離</h2><p>【有向網路】<a href="https://onlinegdb.com/331EsueTm" target="_blank" rel="noopener">從一起始頂點到其餘每一頂點的最短距離</a>  </p><p>定義distance[]為儲存起始頂點到其餘每一頂點最短距離的矩陣<br>定義selected[]為儲存頂點是否被選擇的矩陣  </p><p>Ⅰ 初始化<code>distance</code>與<code>selected</code>，將起始頂點到其餘每一頂點的最短距離儲存於distance，並將起始頂點標記為select<br>Ⅱ 選出最小距離的頂點，將其最小距離儲存於distance並標記為select<br>Ⅲ 將distance中<strong>其他尚未被選擇頂點的距離</strong>與<strong>被選出頂點其最小距離+被選出頂點到該點的原始距離</strong>進行比較，若較小則更新  </p><p>頂點0到其他頂點的最短距離<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3fkpGlKWLA6gE6Of8SO9wtc--Cv6OcVVmPPK-oKem1n1WpTFkh4-8Cx8B1ufBnjo7SJAPVXcTlLEf5St6kSWYlQoSU3c_w1aYvZZrQXknZ8OcDXQ4NdWUaAXvHk3KedQ5L26g6pOkOTu93PyoOmkzo=w1302-h937-no?authuser=1" alt="有向網路-從一起始頂點到其餘每一頂點的最短距離"></p><h2 id="任兩頂點間之最短距離"><a href="#任兩頂點間之最短距離" class="headerlink" title="任兩頂點間之最短距離"></a>任兩頂點間之最短距離</h2><p>【有向網路】<a href="https://onlinegdb.com/VA_6GlVaXs" target="_blank" rel="noopener">任兩頂點間之最短距離</a><br><img src="https://lh3.googleusercontent.com/pw/ACtC-3d-BNR6O6b4q-AnvD0JgOL9OTnjuo4-3JZFv6nOjb6NkhOc8dlFJl1a5UHQbAbgxAzDJJREgtlZJpWwquVMWwBuPOlKGNE13XM7wx0WN20x-H5pAGNIOXrgochMvih-oSM-L2x2aNpplZd1o6yaXAQ=w1807-h868-no?authuser=1" alt="有向網路-任兩頂點間之最短距離"><br>將N個頂點依序編號(0, 1, …, N-1)<br>Ⅰ 定義A<sup>-1</sup>為任兩頂點間最原始的距離矩陣<br>Ⅱ 定義k(0 &lt;= k &lt;= N-1) 限制頂點i到頂點j的<strong>路徑不得通過大於編號k的頂點</strong><br>Ⅲ <strong>k-1距離矩陣中的距離</strong>與<strong>頂點i通過頂點k到頂點j的距離</strong>(i-j-k)選擇較小者<br>當k=N-1，即可得任兩頂點間之最短距離矩陣</p><h2 id="AOV-Activity-on-Vertex-Network"><a href="#AOV-Activity-on-Vertex-Network" class="headerlink" title="AOV (Activity on Vertex) Network"></a>AOV (Activity on Vertex) Network</h2><ul><li>應用於工作規劃</li><li>一頂點(Vertex) = 一項工作(Activity)</li></ul><h3 id="拓樸排序-Topology-Sort"><a href="#拓樸排序-Topology-Sort" class="headerlink" title="拓樸排序 (Topology Sort)"></a>拓樸排序 (Topology Sort)</h3><p><a href="https://onlinegdb.com/ry-MrF9lu" target="_blank" rel="noopener">AOV-拓樸排序</a><br>依序列出AOV Network中的所有頂點，並維持先後順序。<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3dyoI8DDD5lHd2BnWeNqCaA_a58xYX8yUmPzNNCdgQBNJsFgjjWoaehQr5Ufj1hKG0ITZ9zy0p8QnQ2WZn3Qz5nuOBmhCUHSDAOjrU49Zm6dtSjTuEQJv-NJb6N-FHsr4w8QunR2Q7HX7nAke07cdo=w1524-h937-no?authuser=1" alt="AOV-拓樸排序"><br>Ⅰ 任選一個<strong>沒有predecessor</strong>(整行為0)的頂點<br>Ⅱ 將該頂點與其相關的邊刪除(刪除該頂點的欄與列)<br>Ⅲ 重複執行ⅠⅡ，直到所有頂點都已選擇  </p><p>在程式中透過selected_ver矩陣標記被選擇的頂點，以刪除該頂點與其相關的邊，避免被重複選擇。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Graph&quot;&gt;&lt;a href=&quot;#Graph&quot; class=&quot;headerlink&quot; title=&quot;Graph&quot;&gt;&lt;/a&gt;Graph&lt;/h1&gt;&lt;p&gt;圖形(Graph)由&lt;strong&gt;頂點(Vertics/Nodes)集合&lt;/strong&gt;與&lt;strong&gt;邊(Edges)集合&lt;/strong&gt;組成。&lt;code&gt;G=(V,E)&lt;/code&gt;&lt;br&gt;透過&lt;strong&gt;頂點&lt;/strong&gt;儲存資料，透過&lt;strong&gt;邊&lt;/strong&gt;表示頂點間的連通關係，依照有無方向性區分成&lt;code&gt;&amp;lt;有向圖&amp;gt;&lt;/code&gt;與&lt;code&gt;(無向圖)&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;完全圖: 圖形中的每一個頂點皆與其他頂點相互連接。&lt;br&gt;無向完全圖: |E| = N(N-1) / 2&lt;br&gt;有向完全圖: |E| = N(N-1)&lt;/p&gt;
&lt;div class=&quot;columns is-multiline&quot;&gt;
  &lt;div class=&quot;column is-half is-12-mobile&quot;&gt;
  有向圖 (Directed Graph)
  &lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3ff0Krpy5cP31zknom7aYMXzkPdggWKUJb2LG-F8AlFqgLJGtXYhPZNC9EnDwqF35BxEaRrE0w7XiN14lP_9FBoVUgd31a7y9OHhNbG4xRMbgkxzgGW0pWMRAIBGhMeweIIh-JprIgTs_zL7E1NdCo=w397-h346-no?authuser=1&quot;&gt;
  &lt;/div&gt;
  &lt;div class=&quot;column is-half is-12-mobile&quot;&gt;
  無向圖 (Undirected Graph)
  &lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3e5kKo4WxDXdAyfpezVx07IRyRMhPv_Ph6m8A7sxyOuGbHXsxM7_r0Aqjcfo2cWx08R37y7xmjH_gXC8qvSnMsAM0Dx47pEH1ahz6wtyL0uCAy6x-tMn22lk0948NHnAaXT8F1AbfKVDKzJ9u8kwoc=w397-h346-no?authuser=1&quot;&gt;
  &lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="Data Structure" scheme="https://InkyChew.github.io/categories/Notes/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="https://InkyChew.github.io/tags/Data-Structure/"/>
    
      <category term="Graph" scheme="https://InkyChew.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>C語言的那些事</title>
    <link href="https://InkyChew.github.io/c-program/"/>
    <id>https://InkyChew.github.io/c-program/</id>
    <published>2021-01-30T01:02:36.000Z</published>
    <updated>2021-04-03T06:26:30.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指標-Poiter"><a href="#指標-Poiter" class="headerlink" title="指標 Poiter"></a>指標 Poiter</h1><p>指標存<strong>記憶體位址</strong><br>透過指標變數提取記憶位址<br>宣告指標變數 <code>型態 *名稱</code></p><p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> *num_p; <span class="hljs-comment">/*宣告指標變數*/</span></span><br><span class="line"><span class="hljs-keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">num_p = &amp;num; <span class="hljs-comment">/*讓指標變數num_p指向變數num的記憶體位址*/</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># Call by value</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>;</span><br><span class="line">  swap(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> temp;</span><br><span class="line">  temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>將變數x、y的<strong>值</strong>傳給變數a、b。進行swap()之後，變數a、b的值改變，但變數x與y的值不變。</p><h1 id="Call-by-reference"><a href="#Call-by-reference" class="headerlink" title="Call by reference"></a>Call by reference</h1><p><code>&amp;</code> 表變數的位址<br><code>*</code> 指標變數中，儲存位址所指向的值<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>;</span><br><span class="line">  swap(&amp;x, &amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>將變數x、y的<strong>記憶體位址</strong>傳給指標變數a、b。也就是說，使用指標變數a、b，儲存變數x、y的記憶體位址。進行swap()之後，指標變數a、b儲存的記憶體位址互換，因此變數x與y的值改變。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指標-Poiter&quot;&gt;&lt;a href=&quot;#指標-Poiter&quot; class=&quot;headerlink&quot; title=&quot;指標 Poiter&quot;&gt;&lt;/a&gt;指標 Poiter&lt;/h1&gt;&lt;p&gt;指標存&lt;strong&gt;記憶體位址&lt;/strong&gt;&lt;br&gt;透過指標變數提取記憶位址&lt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="C" scheme="https://InkyChew.github.io/tags/C/"/>
    
      <category term="pointer" scheme="https://InkyChew.github.io/tags/pointer/"/>
    
  </entry>
  
  <entry>
    <title>Design pattern - Visitor</title>
    <link href="https://InkyChew.github.io/oo-dp-visitor/"/>
    <id>https://InkyChew.github.io/oo-dp-visitor/</id>
    <published>2020-12-27T08:57:17.000Z</published>
    <updated>2021-05-03T12:13:54.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h1><blockquote><p><strong>Represent an operation</strong> to be performed on an object structure. Visitor lets you <strong>define a new operation without changing the classes</strong> of the elements on which it operates.</p></blockquote><h2 id="Use-when"><a href="#Use-when" class="headerlink" title="Use when"></a>Use when</h2><ul><li><strong>Object structure固定不變，但方法需要不斷擴充時</strong><br>當Object structure中的concrete classes有許多不同且不相關的方法，使用Visitor pattern，讓concrete classes在需要擴充新方法時，不需要進行改變。</li><li>不同的concrete class執行方法不同</li></ul><p>想像有一個公園，裡面有樹，草皮，長椅，步道。有工人與民眾這兩個角色可以到這個公園裡面從事活動。<br>工人修剪樹木、整理草皮、維護長椅、清理步道；民眾坐在樹下、躺在草皮上、坐在長椅上、在步道上散步。</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fYYhT9krXvCSfApPWoWH4psdLwVV3Ykk6q4Te4s_ilmOod2CyGZAjzw-UNYSuesBq2i0rhPmRXAOqtQKFRCLC5v39MU2YM_I9KNo4STzMOcdCf0u03DDWU5_goiLjl1l1N5iOPZhNO2OM-ySAxE7w=w1369-h937-no?authuser=1" alt="Visitor"></p><p><em>此處的 Object structure 為 <a href>Composite</a>，也可以是Collection(list / set)</em></p><a id="more"></a><p>使用Visitor pattern前:<br>parkComponent (Object structure)中有維護與計算人數的方法。每一個Concrete class維護的方法與計算人數的依據皆不同。<br>例如: Tree的維護方法為Worker修剪，並依據是否有樹蔭來計算人數；Bench的維護方法為Worker修理，並依據是否壞掉來計算人數。為了改善concrete classes中有許多不同且不相關方法的問題，使用visitor pattern將方法整合到visitor中，以提高cohesion。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">parkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countVisited</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">parkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// worker cut the tree</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countVisited</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// if have shadowing</span></span><br><span class="line">    <span class="hljs-comment">// citizen++</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bench</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">parkComponent</span>  </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// worker repair the bench</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countVisited</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// if bench is not broken</span></span><br><span class="line">    <span class="hljs-comment">// citizen++</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Visitor pattern後:<br>不同的Visitor根據不同的concrete classes執行不同的方法<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTree</span><span class="hljs-params">(Tree tree)</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitGress</span><span class="hljs-params">(Gress gress)</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitBench</span><span class="hljs-params">(Bench bench)</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTrail</span><span class="hljs-params">(Trail trail)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTree</span><span class="hljs-params">(Tree tree)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// trim</span></span><br><span class="line">    tree.overgrowth = <span class="hljs-keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitGress</span><span class="hljs-params">(Gress gress)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// mow</span></span><br><span class="line">    gress.overgrowth = <span class="hljs-keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitBench</span><span class="hljs-params">(Bench bench)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// repair</span></span><br><span class="line">    bench.broken = <span class="hljs-keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTrail</span><span class="hljs-params">(Trail trail)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// clean</span></span><br><span class="line">    trail.messy = <span class="hljs-keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citizen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTree</span><span class="hljs-params">(Tree tree)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// sit under the tree</span></span><br><span class="line">    visited++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitGress</span><span class="hljs-params">(Gress gress)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!tree.overgrowth) &#123;</span><br><span class="line">      <span class="hljs-comment">// lay on the gress</span></span><br><span class="line">      visited++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// call worker to mow</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitBench</span><span class="hljs-params">(Bench bench)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!bench.broken) &#123;</span><br><span class="line">      <span class="hljs-comment">// sit on the bench</span></span><br><span class="line">      visited++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// call worker to repair</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTrail</span><span class="hljs-params">(Trail trail)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// walk on the trail</span></span><br><span class="line">    visited++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> visited;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">boolean</span> overgrowth;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor v)</span> </span>&#123;</span><br><span class="line">    v.visitTree(<span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gress</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">boolean</span> overgrowth;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor v)</span> </span>&#123;</span><br><span class="line">    v.visitGress(<span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bench</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">boolean</span> broken;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor v)</span> </span>&#123;</span><br><span class="line">    v.visitBench(<span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParkComponent</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">boolean</span> messy;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor v)</span> </span>&#123;</span><br><span class="line">    v.visitTrail(<span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><p>Pros:  </p><ol><li>遵守<a href="https://inkychew.github.io/oo-principle/#2-OCP-Open-Closed-Principle">Open-Closed principle</a>。可以在不改變Object structure的情況下，輕鬆的擴充新方法</li><li>Visiting across class hierarchies. 可以visit 沒有統一抽象介面(abstract class / interface)的elements；也就是說，可以在visitor當中加入任何type的elements<br><a href>Interator</a>也可以visit Object structure，但是必須要有統一的抽象介面</li><li>Accumulating state. 當visit Object structure中的每一個element時，可以積累state<br>例如例子當中visited變數的累計，當Citizen visit Park中的每一個element時<code>visited+1</code><br><em>沒有使用Visitor時，會以globle variable或傳遞參數的方式來改變這個state</em></li></ol><p>Cons:  </p><ol><li>Concrete element新增困難。每新增一個新的concrete element，abstract visitor和相關的concrete visitor必須新增方法，供此concrete element使用<br>所以只應該<strong>在element hierarchy固定不變，但新方法會需要不斷擴充的情況下使用Visitor pattern</strong></li><li>破壞封裝。concrete element的attribute可以被visitor修改</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Visitor&quot;&gt;&lt;a href=&quot;#Visitor&quot; class=&quot;headerlink&quot; title=&quot;Visitor&quot;&gt;&lt;/a&gt;Visitor&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Represent an operation&lt;/strong&gt; to be performed on an object structure. Visitor lets you &lt;strong&gt;define a new operation without changing the classes&lt;/strong&gt; of the elements on which it operates.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Use-when&quot;&gt;&lt;a href=&quot;#Use-when&quot; class=&quot;headerlink&quot; title=&quot;Use when&quot;&gt;&lt;/a&gt;Use when&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Object structure固定不變，但方法需要不斷擴充時&lt;/strong&gt;&lt;br&gt;當Object structure中的concrete classes有許多不同且不相關的方法，使用Visitor pattern，讓concrete classes在需要擴充新方法時，不需要進行改變。&lt;/li&gt;
&lt;li&gt;不同的concrete class執行方法不同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想像有一個公園，裡面有樹，草皮，長椅，步道。有工人與民眾這兩個角色可以到這個公園裡面從事活動。&lt;br&gt;工人修剪樹木、整理草皮、維護長椅、清理步道；民眾坐在樹下、躺在草皮上、坐在長椅上、在步道上散步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3fYYhT9krXvCSfApPWoWH4psdLwVV3Ykk6q4Te4s_ilmOod2CyGZAjzw-UNYSuesBq2i0rhPmRXAOqtQKFRCLC5v39MU2YM_I9KNo4STzMOcdCf0u03DDWU5_goiLjl1l1N5iOPZhNO2OM-ySAxE7w=w1369-h937-no?authuser=1&quot; alt=&quot;Visitor&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此處的 Object structure 為 &lt;a href&gt;Composite&lt;/a&gt;，也可以是Collection(list / set)&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="OOSE" scheme="https://InkyChew.github.io/categories/Notes/OOSE/"/>
    
    
      <category term="Design pattern" scheme="https://InkyChew.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="https://InkyChew.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Sorting algorithm - Merge sort</title>
    <link href="https://InkyChew.github.io/algo-sort-merge/"/>
    <id>https://InkyChew.github.io/algo-sort-merge/</id>
    <published>2020-12-26T02:47:42.000Z</published>
    <updated>2021-05-03T12:23:26.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h1><p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Merge-Sort-Tutorial.png" alt="Merge sort"></p><ol><li>重複將資料從中間切成左右兩半，直到切出來的每一半只剩下一個元素</li><li>由小到大合併左右兩半<ul><li>新增左右兩半兩個陣列</li><li>比較左右兩半元素的大小，進行合併<a id="more"></a></li></ul></li></ol><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// divide(arr, 0, arr.length-1);</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l+r) / <span class="hljs-number">2</span>;</span><br><span class="line">    divide(arr, l, mid);</span><br><span class="line">    divide(arr, mid+<span class="hljs-number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 新增左右兩半兩個陣列</span></span><br><span class="line">  l_size = m-l+<span class="hljs-number">1</span>;</span><br><span class="line">  r_size = r-m;</span><br><span class="line">  <span class="hljs-keyword">int</span> L[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[l_size];</span><br><span class="line">  <span class="hljs-keyword">int</span> R[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r_size];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 將原陣列中的元素複製到左右陣列中</span></span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l_size; i++)</span><br><span class="line">    L[i] = arr[l+i];</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r_size; i++)</span><br><span class="line">    R[i] = arr[m+<span class="hljs-number">1</span>+i];</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 比較左右兩半元素的大小，進行合併</span></span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> k = l;</span><br><span class="line">  <span class="hljs-comment">// 當&lt;左右兩半&gt;或&lt;其中一半&gt;沒有元素時，跳出迴圈</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (i &lt; l_size &amp;&amp; r &lt; r_size) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(L[i] &lt; R[j]) &#123;</span><br><span class="line">      arr[k] = L[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      arr[k] = R[j];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 當左半還有元素時，將元素加入至合併陣列中</span></span><br><span class="line">  <span class="hljs-keyword">while</span>(i &lt; l_size) &#123;</span><br><span class="line">    arr[k] = L[i];</span><br><span class="line">    i++;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 當右半還有元素時，將元素加入至合併陣列中</span></span><br><span class="line">  <span class="hljs-keyword">while</span>(j &lt; r_size) &#123;</span><br><span class="line">    arr[k] = R[j];</span><br><span class="line">    j++;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cPT7TGovbYfFEl7exTfcqn55foHPR6lzAglYxGW5L-KysBrp2KMapJbjPQpAG8iYsdIQm0nkV-OSObjgGiQk59fPFedFDAbErXoz07bA9WbgELxSUCsF0_EfQR3wIjUtOjcMzt2bxuf62o5eUTP5s=w561-h591-no?authuser=1" alt="merge sort"></p><h3 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h3><p>Worst case: O(n logn)<br>Best case: O(n logn)<br>divide() = log n ; merge() = n</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.geeksforgeeks.org/merge-sort/" target="_blank" rel="noopener">geeksforgeeks-Merge sort</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Merge-sort&quot;&gt;&lt;a href=&quot;#Merge-sort&quot; class=&quot;headerlink&quot; title=&quot;Merge sort&quot;&gt;&lt;/a&gt;Merge sort&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/cdn-uploads/Merge-Sort-Tutorial.png&quot; alt=&quot;Merge sort&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重複將資料從中間切成左右兩半，直到切出來的每一半只剩下一個元素&lt;/li&gt;
&lt;li&gt;由小到大合併左右兩半&lt;ul&gt;
&lt;li&gt;新增左右兩半兩個陣列&lt;/li&gt;
&lt;li&gt;比較左右兩半元素的大小，進行合併&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="Algorithm" scheme="https://InkyChew.github.io/categories/Notes/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://InkyChew.github.io/tags/algorithm/"/>
    
      <category term="sorting" scheme="https://InkyChew.github.io/tags/sorting/"/>
    
  </entry>
  
  <entry>
    <title>Sorting algorithm - Insertion sort</title>
    <link href="https://InkyChew.github.io/algo-sort-insertion/"/>
    <id>https://InkyChew.github.io/algo-sort-insertion/</id>
    <published>2020-12-25T06:15:04.000Z</published>
    <updated>2021-05-03T12:25:33.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Insertion-sort-插入排序法"><a href="#Insertion-sort-插入排序法" class="headerlink" title="Insertion sort 插入排序法"></a>Insertion sort 插入排序法</h1><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3f0fMpUsh5OLJPIc9jfuB45VDFlHYFRFzoRf8lxxhiyqfUXzNMjoHhD2QivbKCiweEOjuUZ4dotIr7Zu3bcC3_Iyc3maZA0-k_YcJnnU7WF1ZhIfBc5ZsqGP43b0oyGI--4e5zEN7I4kohp7KtbMnk=w556-h153-no?authuser=1" alt="Insertion sort"><br>將資料分成已排序(sorted)與未排序(unsorted)兩部分，依序取出未排序部分的第一個數值(目標值)，將其插入到已排序部分當中的正確位置。將目標值由右向左依序與已排序部分中的數值進行比較，當已排序部分中的數值大於目標值則往右移一個位置，否則將目標值插入。</p><a id="more"></a><p>將以上的敘述拆解:</p><ol><li>依序取出未排序部分的第一個數值(目標值)</li><li>將目標值由右向左依序與已排序部分中的數值進行比較</li><li>當已排序部分中的數值大於目標值則往右移，否則將目標值插入。</li></ol><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;  <span class="hljs-comment">// 1.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> target = arr[i];</span><br><span class="line">  <span class="hljs-keyword">int</span> j = i-<span class="hljs-number">1</span>;                          <span class="hljs-comment">// 2.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; target) &#123;   <span class="hljs-comment">// 3.</span></span><br><span class="line">    arr[j+<span class="hljs-number">1</span>] = arr[j];</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[j+<span class="hljs-number">1</span>] = target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h3><p>Worst case: O(n*2)<br>Best case: O(n)  </p><p>適合在資料<strong>幾乎已經排序</strong>完成或<strong>資料量很小</strong>的時候使用</p><!-- ## Insertion Sort for Singly Linked List --><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.geeksforgeeks.org/insertion-sort/" target="_blank" rel="noopener">geeksforgeeks-Insertion sort</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Insertion-sort-插入排序法&quot;&gt;&lt;a href=&quot;#Insertion-sort-插入排序法&quot; class=&quot;headerlink&quot; title=&quot;Insertion sort 插入排序法&quot;&gt;&lt;/a&gt;Insertion sort 插入排序法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3f0fMpUsh5OLJPIc9jfuB45VDFlHYFRFzoRf8lxxhiyqfUXzNMjoHhD2QivbKCiweEOjuUZ4dotIr7Zu3bcC3_Iyc3maZA0-k_YcJnnU7WF1ZhIfBc5ZsqGP43b0oyGI--4e5zEN7I4kohp7KtbMnk=w556-h153-no?authuser=1&quot; alt=&quot;Insertion sort&quot;&gt;&lt;br&gt;將資料分成已排序(sorted)與未排序(unsorted)兩部分，依序取出未排序部分的第一個數值(目標值)，將其插入到已排序部分當中的正確位置。將目標值由右向左依序與已排序部分中的數值進行比較，當已排序部分中的數值大於目標值則往右移一個位置，否則將目標值插入。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="Algorithm" scheme="https://InkyChew.github.io/categories/Notes/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://InkyChew.github.io/tags/algorithm/"/>
    
      <category term="sorting" scheme="https://InkyChew.github.io/tags/sorting/"/>
    
  </entry>
  
  <entry>
    <title>Sorting algorithm - Bubble sort</title>
    <link href="https://InkyChew.github.io/algo-sort-bubble/"/>
    <id>https://InkyChew.github.io/algo-sort-bubble/</id>
    <published>2020-12-24T14:19:30.000Z</published>
    <updated>2021-05-03T12:24:54.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bubble-sort-氣泡排序法"><a href="#Bubble-sort-氣泡排序法" class="headerlink" title="Bubble sort 氣泡排序法"></a>Bubble sort 氣泡排序法</h1><p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2014/02/bubble-sort1.png" alt></p><p>每一次比較兩個相鄰數值，如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置。因為已經確保最大數值的位置，因此下一次需要比較的數值會少一個。</p><a id="more"></a><p>將以上的敘述拆解:</p><ol><li><p>每一次比較兩個相鄰元素<br>思考要比較幾次?<br>假設有五個數值，兩兩相比需比較四次。我們可以用<code>arr.length-1</code>表示。<br> <img src="https://lh3.googleusercontent.com/pw/ACtC-3eNYWpkdsPVS6ZY0uU-IqwmSPLBsA-dObTqsmqVKoGGSgiyCgZneErULqAEoxGXBnEv9XotQgDb_1gx9WURp-uUc-4rcE44zkZmAtz7neHkAlIivhCvz6aemDvXdBc4rzjphXNMoCOaCxeph5-tTkg=w163-h81-no?authuser=1" alt="兩相鄰元素比較次數"><br> 兩相鄰元素比較次數 = 總元素數量-1 </p></li><li><p>下一次需要比較的元素會少一個<br>第0次比較兩個相鄰元素，( 總元素數量-0 )-1個數值<br>第1次比較兩個相鄰元素，( 總元素數量-1 )-1個數值<br>第2次比較兩個相鄰元素，( 總元素數量-2 )-1個數值<br>…<br>第<code>i</code>次比較兩個相鄰元素，<code>arr.length-i-1</code>個數值  </p></li><li><p>如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置</p></li></ol><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 1.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length-i-<span class="hljs-number">1</span>; j++) &#123;    <span class="hljs-comment">// 2.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;                    <span class="hljs-comment">// 3.</span></span><br><span class="line">      <span class="hljs-keyword">int</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j+<span class="hljs-number">1</span>];</span><br><span class="line">      arr[j+<span class="hljs-number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Time complexity: O(n*n)<br>上述的程式碼缺乏效率，儘管陣列中所有的元素都已經排序完成，程式依然執行<code>n*n</code>次。  </p><p>觀察下方的圖片幫助理解<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3e5qKBV0HclSwZ1SPanKcFmM-DkNNliNTyu9wMfzCkZjTVIL3jJPeR17NEywfMvZi3bxsbE_lWOkIQe55JYNTeQnv0kL4BuAYpLzcApeDIFB70GwMdQptHysPvrZznQFBelJQ3fZ2mTgY05xs3ZUXo=w554-h267-no?authuser=1" alt="缺乏效率的bubble sort"><br>我們可以發現執行第6次時就已經完成排序，但卻執行了10次</p><h2 id="Optimized-implementation"><a href="#Optimized-implementation" class="headerlink" title="Optimized implementation"></a>Optimized implementation</h2><p>如何知道所有的元素已經排序完成?<br>當兩相鄰元素的交換不再發生時，即完成所有元素的排序</p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">boolean</span> swapped = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length-i-<span class="hljs-number">1</span>; j++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j+<span class="hljs-number">1</span>]) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j+<span class="hljs-number">1</span>];</span><br><span class="line">      arr[j+<span class="hljs-number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-comment">// 當有交換發生時，將swapped設成true</span></span><br><span class="line">      swapped = <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 當兩相鄰元素的交換不再發生時</span></span><br><span class="line">  <span class="hljs-comment">// 所有元素排序完成</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (swapped == <span class="hljs-keyword">false</span>)</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h3><p>Worst case: O(n*n)<br>所需執行時間的最壞情況，發生在陣列當中的元素以反向排序時<br>Best case: O(n)<br>所需執行時間的最佳情況，發生在陣列當中的元素已經排序好時</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.geeksforgeeks.org/bubble-sort/" target="_blank" rel="noopener">geeksforgeeks-Bubble sort</a><br><a href="https://pjchender.blogspot.com/2017/09/bubble-sort.html" target="_blank" rel="noopener">[演算法] 氣泡排序法 Bubble Sort</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Bubble-sort-氣泡排序法&quot;&gt;&lt;a href=&quot;#Bubble-sort-氣泡排序法&quot; class=&quot;headerlink&quot; title=&quot;Bubble sort 氣泡排序法&quot;&gt;&lt;/a&gt;Bubble sort 氣泡排序法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2014/02/bubble-sort1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;每一次比較兩個相鄰數值，如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置。因為已經確保最大數值的位置，因此下一次需要比較的數值會少一個。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="Algorithm" scheme="https://InkyChew.github.io/categories/Notes/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://InkyChew.github.io/tags/algorithm/"/>
    
      <category term="sorting" scheme="https://InkyChew.github.io/tags/sorting/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="https://InkyChew.github.io/algo/"/>
    <id>https://InkyChew.github.io/algo/</id>
    <published>2020-12-24T09:56:54.000Z</published>
    <updated>2021-01-27T08:14:06.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="演算法-Algorithm"><a href="#演算法-Algorithm" class="headerlink" title="演算法 (Algorithm)"></a>演算法 (Algorithm)</h1><ul><li>解決問題的流程</li><li>滿足五條件<ol><li>輸入 可有可無</li><li>輸出 至少要有一個</li><li>有限性 有限步驟內解決問題</li><li>明確性 步驟清楚明確、條理分明</li><li>有效性 必須能夠解決問題</li></ol></li><li>表示方式<ol><li>Psuedo code</li><li>Flow chart</li></ol></li></ul><h2 id="演算法系列文章"><a href="#演算法系列文章" class="headerlink" title="演算法系列文章"></a>演算法系列文章</h2><p><a href="https://inkychew.github.io/algo-timeComplexity/">時間複雜度（Time Complexity）&amp; big-O</a><br>空間複雜度</p><ol><li>資料結構的各項操作</li><li>排序（Sorting）：<ul><li><a href="http://inkychew.github.io/algo-sort-bubble/">Bubble sort</a>  O(n*n) </li><li><a href="https://inkychew.github.io/algo-sort-merge/">Insertion sort</a>  O(n*2) </li><li>Quick sort</li><li><a href="https://inkychew.github.io/algo-sort-insertion/">Merge sort</a> O(n logn)</li></ul></li><li>搜尋（Searching）<ul><li>Depth-first-search</li><li>Breadth-first-search</li><li>Binary search  </li></ul></li></ol><p><a href="https://inkychew.github.io/recursion/">遞迴（recursive）</a><br>分治法（divide and conquer）<br>迭代（iteration）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;演算法-Algorithm&quot;&gt;&lt;a href=&quot;#演算法-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;演算法 (Algorithm)&quot;&gt;&lt;/a&gt;演算法 (Algorithm)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;解決問題的流程&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="Algorithm" scheme="https://InkyChew.github.io/categories/Notes/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://InkyChew.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Time Complexity</title>
    <link href="https://InkyChew.github.io/algo-timeComplexity/"/>
    <id>https://InkyChew.github.io/algo-timeComplexity/</id>
    <published>2020-12-23T11:48:38.000Z</published>
    <updated>2020-12-24T09:53:09.780Z</updated>
    
    <content type="html"><![CDATA[<p>在寫程式時，同一個問題，可以有多個不同的解法，因此我們需要衡量不同方法的時間與空間複雜度，以找到最佳的解法。在現代，儲存空間已經不是太大的問題，因此我們關注程式的效率，也就是演算法的時間複雜度(Time Complexity)。  </p><h1 id="Time-Complexity-時間複雜度"><a href="#Time-Complexity-時間複雜度" class="headerlink" title="Time Complexity 時間複雜度"></a>Time Complexity 時間複雜度</h1><p><strong>隨著輸入資料量的增加，執行時間的變化</strong><br>使用Asymptotic Notation表示時間複雜度。</p><h2 id="Asymptotic-Notation-漸近符號"><a href="#Asymptotic-Notation-漸近符號" class="headerlink" title="Asymptotic Notation 漸近符號"></a>Asymptotic Notation 漸近符號</h2><ul><li>Big-O ( Ο ): 以<code>Ο()</code>表示演算法所需執行時間的最<strong>壞</strong>情況</li><li>Omega ( Ω ): 以<code>Ω()</code>表示演算法所需執行時間的最<strong>佳</strong>情況</li><li>Theta ( θ ): 以<code>θ()</code>表示演算法所需執行時間的<strong>範圍</strong>，包含了最壞與最佳情況</li></ul><p>時間複雜度所需執行時間，由短到長:<br><code>1(常數)</code> &lt; <code>log n</code> &lt; <code>n</code> &lt; <code>n log n</code> &lt; <code>n^2</code> &lt; <code>2^n</code> &lt; <code>n!</code></p><a id="more"></a><h2 id="以Big-O表示時間複雜度的四種常見類型"><a href="#以Big-O表示時間複雜度的四種常見類型" class="headerlink" title="以Big-O表示時間複雜度的四種常見類型"></a>以Big-O表示時間複雜度的四種常見類型</h2><h3 id="1-Constant-Run-Time-O-1"><a href="#1-Constant-Run-Time-O-1" class="headerlink" title="1. Constant Run Time (O(1))"></a>1. Constant Run Time (O(1))</h3><p>不管資料量大小，執行時間都<strong>一樣</strong>。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</span><br><span class="line"><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constant</span>(<span class="hljs-params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 不管傳入arr或arr2，執行次數皆為一次。</span></span><br></pre></td></tr></table></figure></p><h3 id="2-Logarithmic-Run-Time-O-log-n"><a href="#2-Logarithmic-Run-Time-O-log-n" class="headerlink" title="2. Logarithmic Run Time (O(log n))"></a>2. Logarithmic Run Time (O(log n))</h3><p>隨著資料量增加，執行時間<strong>趨緩</strong>。<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">  n = n / <span class="hljs-number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** var n = 10  </span></span><br><span class="line"><span class="hljs-comment">  * n -&gt; 10, 5, 2, 1, 0  </span></span><br><span class="line"><span class="hljs-comment">  * var n = 15  </span></span><br><span class="line"><span class="hljs-comment">  * n -&gt; 7, 3, 1, 0</span></span><br><span class="line"><span class="hljs-comment">  **/</span></span><br></pre></td></tr></table></figure></p><h3 id="3-Linear-Run-Time-O-n"><a href="#3-Linear-Run-Time-O-n" class="headerlink" title="3. Linear Run Time (O(n))"></a>3. Linear Run Time (O(n))</h3><p>隨著資料量增加，執行時間成<strong>線性等比例</strong>成長。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 執行次數為n次</span></span><br></pre></td></tr></table></figure></p><h3 id="4-Exponential-Run-Time-O-n-2"><a href="#4-Exponential-Run-Time-O-n-2" class="headerlink" title="4. Exponential Run Time (O(n^2))"></a>4. Exponential Run Time (O(n^2))</h3><p>隨著資料量增加，執行時間成<strong>指數成長</strong>。<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 執行次數為n*n次</span></span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/KdyjYI5.png" alt="Big O Notation"></p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://medium.com/@yunyubee/%E6%BC%94%E7%AE%97%E6%B3%95-big-o-and-time-complexity-65f2dfafe9d1" target="_blank" rel="noopener">[演算法] Big O and Time Complexity</a><br><a href="https://pjchender.blogspot.com/2017/09/big-o-notation-time-complexity.html" target="_blank" rel="noopener">[演算法] Big O Notation &amp; Time Complexity</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在寫程式時，同一個問題，可以有多個不同的解法，因此我們需要衡量不同方法的時間與空間複雜度，以找到最佳的解法。在現代，儲存空間已經不是太大的問題，因此我們關注程式的效率，也就是演算法的時間複雜度(Time Complexity)。  &lt;/p&gt;
&lt;h1 id=&quot;Time-Complexity-時間複雜度&quot;&gt;&lt;a href=&quot;#Time-Complexity-時間複雜度&quot; class=&quot;headerlink&quot; title=&quot;Time Complexity 時間複雜度&quot;&gt;&lt;/a&gt;Time Complexity 時間複雜度&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;隨著輸入資料量的增加，執行時間的變化&lt;/strong&gt;&lt;br&gt;使用Asymptotic Notation表示時間複雜度。&lt;/p&gt;
&lt;h2 id=&quot;Asymptotic-Notation-漸近符號&quot;&gt;&lt;a href=&quot;#Asymptotic-Notation-漸近符號&quot; class=&quot;headerlink&quot; title=&quot;Asymptotic Notation 漸近符號&quot;&gt;&lt;/a&gt;Asymptotic Notation 漸近符號&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Big-O ( Ο ): 以&lt;code&gt;Ο()&lt;/code&gt;表示演算法所需執行時間的最&lt;strong&gt;壞&lt;/strong&gt;情況&lt;/li&gt;
&lt;li&gt;Omega ( Ω ): 以&lt;code&gt;Ω()&lt;/code&gt;表示演算法所需執行時間的最&lt;strong&gt;佳&lt;/strong&gt;情況&lt;/li&gt;
&lt;li&gt;Theta ( θ ): 以&lt;code&gt;θ()&lt;/code&gt;表示演算法所需執行時間的&lt;strong&gt;範圍&lt;/strong&gt;，包含了最壞與最佳情況&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;時間複雜度所需執行時間，由短到長:&lt;br&gt;&lt;code&gt;1(常數)&lt;/code&gt; &amp;lt; &lt;code&gt;log n&lt;/code&gt; &amp;lt; &lt;code&gt;n&lt;/code&gt; &amp;lt; &lt;code&gt;n log n&lt;/code&gt; &amp;lt; &lt;code&gt;n^2&lt;/code&gt; &amp;lt; &lt;code&gt;2^n&lt;/code&gt; &amp;lt; &lt;code&gt;n!&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="Algorithm" scheme="https://InkyChew.github.io/categories/Notes/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://InkyChew.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Design pattern - Factory method</title>
    <link href="https://InkyChew.github.io/oo-dp-factory/"/>
    <id>https://InkyChew.github.io/oo-dp-factory/</id>
    <published>2020-12-20T01:49:48.000Z</published>
    <updated>2021-05-03T12:13:33.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Factory-method"><a href="#Factory-method" class="headerlink" title="Factory method"></a>Factory method</h1><blockquote><p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. </p></blockquote><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3c66zil8u1JWFVzULXTFmoBkwWnC3xiihxgVFjcXIWCEz8mGSfA6gr_i1FyY6sZUt03t4LVajdGj0Rjlj7K12nxvp0ct3vtwto7xgfvpJCIgIyiGG-jegbCwTl-SYVcPLwpMSQQ45ku2KojVFinnh4=w1250-h937-no?authuser=1" alt="Factory method"><br>一間工廠(creator)只專門生產一種產品(product)。</p><a id="more"></a><h2 id="Use-when"><a href="#Use-when" class="headerlink" title="Use when"></a>Use when</h2><blockquote><ul><li>a class can’t anticipate the class of objects it must create.</li><li>a class wants its subclasses to specify the objects it creates.</li><li>classes delegate responsibility to one of several helper subclasses, and you want<br>to localize the knowledge of which helper subclass is the delegate.</li></ul></blockquote><p>優點:  </p><ol><li>得以讓被create的product在run time的時候才決定  </li><li>得以明確知道哪一個Creator create 哪一個Product</li><li>得以在superclass建立hooks，為subclass提供default method  </li><li>Connects parallel class hierarchies，creator delegate some of its responsibility to its product.<br>例如:長條圖與折線圖都會用到getData()，但繪製的方式不同。長條圖以棒狀呈現，折線圖以線呈現，這時候creator就可以委託product做變化。<hr></li></ol><p>在<a href="https://inkychew.github.io/oo-dp-observer">observer</a>中提到spreadsheet create chart可以使用factory method。</p><p>spreadsheet不需要綁定特定的chart<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">spreadSheet</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;chart&gt; charts = <span class="hljs-keyword">new</span> ArrayList&lt;Chart&gt;();</span><br><span class="line">  <span class="hljs-keyword">private</span> chartFactory factory;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    factory = configure(); <span class="hljs-comment">// 要使用哪間工廠</span></span><br><span class="line">    Chart chart = factory.createChart(type);</span><br><span class="line">    charts.add(chart);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Creator</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">chartFactory</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> Chart <span class="hljs-title">createChart</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">barChartFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">spreadSheet</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> Chart <span class="hljs-title">createChart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> barChart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lineChartFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">spreadSheet</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> Chart <span class="hljs-title">createChart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> lineChart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缺點:</p><ol><li>有很多的creator，只是為了create product</li><li>client必須判斷要使用哪一個creator</li></ol><p>Factory method與<a href>Abstract factory</a>很像，但Abstract factory強調組合的關係。通常在使用Abstract factory的同時，會使用Factory method。</p><h1 id="Simple-factory"><a href="#Simple-factory" class="headerlink" title="Simple factory"></a>Simple factory</h1><p>只有一間工廠，客戶指定要什麼就生產什麼。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">spreadSheet</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;chart&gt; charts = <span class="hljs-keyword">new</span> ArrayList&lt;Chart&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Chart <span class="hljs-title">createChart</span><span class="hljs-params">(String type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">    Chart chart = chartFactory.createChart(type);</span><br><span class="line">    charts.add(chart);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">chartFactory</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Chart <span class="hljs-title">createChart</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">switch</span>(type) &#123;</span><br><span class="line">      <span class="hljs-keyword">case</span> <span class="hljs-string">"bar"</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> barChart();</span><br><span class="line">      <span class="hljs-keyword">case</span> <span class="hljs-string">"line"</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> lineChart();</span><br><span class="line">      <span class="hljs-keyword">default</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> barChart();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://stackoverflow.com/questions/53372254/simple-factory-vs-factory-method" target="_blank" rel="noopener">Simple factory vs Factory method</a><br>Use SimpleFactory when the types of Objects are <strong>not fixed.</strong><br>Use Factory method when the types of Objects are fixed.<br>當決定好class的數量，使用Factory method。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Factory-method&quot;&gt;&lt;a href=&quot;#Factory-method&quot; class=&quot;headerlink&quot; title=&quot;Factory method&quot;&gt;&lt;/a&gt;Factory method&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3c66zil8u1JWFVzULXTFmoBkwWnC3xiihxgVFjcXIWCEz8mGSfA6gr_i1FyY6sZUt03t4LVajdGj0Rjlj7K12nxvp0ct3vtwto7xgfvpJCIgIyiGG-jegbCwTl-SYVcPLwpMSQQ45ku2KojVFinnh4=w1250-h937-no?authuser=1&quot; alt=&quot;Factory method&quot;&gt;&lt;br&gt;一間工廠(creator)只專門生產一種產品(product)。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="OOSE" scheme="https://InkyChew.github.io/categories/Notes/OOSE/"/>
    
    
      <category term="Design pattern" scheme="https://InkyChew.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="https://InkyChew.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Design pattern - Observer</title>
    <link href="https://InkyChew.github.io/oo-dp-observer/"/>
    <id>https://InkyChew.github.io/oo-dp-observer/</id>
    <published>2020-12-17T12:52:34.000Z</published>
    <updated>2021-05-03T12:13:13.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h1><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its depends are notified and updated automatically.</p></blockquote><p>maintain consistency without tightly coupled to increase reusablity.<br>當兩個object間的資訊需要同步更新的時候，透過observer pattern維護資訊的一致性，並降低之間的coupling。</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3ckpilg6N0QEziGn84xa_CtczRQ25cgPmXpaSfKEKiaJJGdB0eamsHJUQaF14Z7ENe8xWXoQ_hCrMP3opZY3cGOmYJhy2EIvC0Wwn2iXUXnKdvRjOAG_eM03ohacssv4Udet6lFSyB230yL-jhlJxk=w1250-h937-no?authuser=1" alt="Observer"></p><a id="more"></a><p>以Youtube為例<br>使用Youtube時，使用者對喜歡的youtuber按下訂閱，當該Youtuber發布最新的影片時，使用者就可以收到該Youtuber最新的影片。</p><p>When subject changed, notify all observers to update.<br>But… </p><h2 id="Who-triggers-the-update"><a href="#Who-triggers-the-update" class="headerlink" title="Who triggers the update()?"></a>Who triggers the update()?</h2><p>狀態更新可以透過兩種方式，各有優缺點 </p><ol><li>Client call Notify<br>client forgot to call  </li><li>Observer call Notify<br>inefficient</li></ol><h3 id="1-Client-call-Notify"><a href="#1-Client-call-Notify" class="headerlink" title="1. Client call Notify"></a>1. Client call Notify</h3><p>想像使用Youtube時，當使用者對喜歡的youtuber按下訂閱，則觸發addSubscriber將此使用者新增到Youtuber的subscribers List中。<br>當youtuber上傳最新影片時，觸發uploadVideo，通知所有訂閱者(observers)該youtuber(subject)最新的影片。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Subject</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Youtuber</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> ArrayList&lt;Subscriber&gt; subscribers = <span class="hljs-keyword">new</span> ArrayList&lt;Subscriber&gt;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Subscriber sub)</span> </span>&#123;</span><br><span class="line">    subscribers.add(sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Subscriber sub)</span> </span>&#123;</span><br><span class="line">    subscribers.remove(sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (sub : subscribers) &#123;</span><br><span class="line">      sub.update(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">concreteYoutuber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Youtuber</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> Video video;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVideo</span><span class="hljs-params">(Video v)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.video = v;</span><br><span class="line">    <span class="hljs-keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getVideo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> video;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Observer</span></span><br><span class="line">Interface Subscriber &#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Youtuber ytb)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">concreteSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subscriber</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> Video video;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Youtuber ytb)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.video = ytb.getVideo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Client</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span> </span>&#123;</span><br><span class="line">  Youtuber rdEnglish = <span class="hljs-keyword">new</span> concreteYoutuber();</span><br><span class="line">  <span class="hljs-comment">// when user click the subscribe button</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSubscriber</span><span class="hljs-params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    rdEnglish.attach(subscriber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// when youtuber upload video then notify all subscribers</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uploadVideo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    rdEnglish.setVideo(video);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-Observer-call-Notify"><a href="#2-Observer-call-Notify" class="headerlink" title="2. Observer call Notify"></a>2. Observer call Notify</h3><p>想像在Excel中，為一張試算表的資料繪製一張長條圖與折線圖。按下新增圖表，觸發attach方法，以建立圖表。(可以透過<a href="https://inkychew.github.io/oo-dp-factory/">Factory method</a>建立不同的圖表)<br>當改變試算表中的資料時，觸發setData，並呼叫Notify以同步更新其他圖表的資料。<br>當改變圖表中的資料時，觸法setChartData，呼叫sheet的setData方法更新試算表的資料，並呼叫Notify同步更新其他圖表的資料。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Subject</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">spreadSheet</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;chart&gt; charts = <span class="hljs-keyword">new</span> ArrayList&lt;Chart&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Chart chart = <span class="hljs-keyword">new</span> Chart();</span><br><span class="line">    charts.add(chart);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Chart chart)</span> </span>&#123;</span><br><span class="line">    charts.remove(chart);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(c : charts) &#123;</span><br><span class="line">      c.update(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">concreteSpreadSheet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">spreadSheet</span> </span>&#123;</span><br><span class="line">  Data data = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setData</span><span class="hljs-params">(Data newData)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.data = newData;</span><br><span class="line">    <span class="hljs-keyword">this</span>.Notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> Data <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Observer</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chart</span> </span>&#123;</span><br><span class="line">  spreadSheet sheet;</span><br><span class="line">  Data data;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(spreadSheet sheet)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.sheet = sheet;</span><br><span class="line">    <span class="hljs-keyword">this</span>.data = sheet.getData();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChartData</span> <span class="hljs-params">(Data newData)</span> </span>&#123;</span><br><span class="line">    sheet.setData(newData);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sheet.detach(<span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">barChart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Chart</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lineChart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Chart</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><p>Pros:</p><ol><li>Coupling between subjects and observers is abstract and minimal. </li><li>Subject and Observer can vary independently. </li></ol><p>Subject不需要知道要更新哪些Observer。兩者可獨立的變化，提高複用性。 </p><p>Cons:</p><ol><li>Unexpected updates.  </li></ol><p>Observer不需要知道其他的Observer。雖然降低coupling，但可能造成資訊更新難以追蹤，資訊更新錯誤的問題。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Observer&quot;&gt;&lt;a href=&quot;#Observer&quot; class=&quot;headerlink&quot; title=&quot;Observer&quot;&gt;&lt;/a&gt;Observer&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Define a one-to-many dependency between objects so that when one object changes state, all its depends are notified and updated automatically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;maintain consistency without tightly coupled to increase reusablity.&lt;br&gt;當兩個object間的資訊需要同步更新的時候，透過observer pattern維護資訊的一致性，並降低之間的coupling。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/pw/ACtC-3ckpilg6N0QEziGn84xa_CtczRQ25cgPmXpaSfKEKiaJJGdB0eamsHJUQaF14Z7ENe8xWXoQ_hCrMP3opZY3cGOmYJhy2EIvC0Wwn2iXUXnKdvRjOAG_eM03ohacssv4Udet6lFSyB230yL-jhlJxk=w1250-h937-no?authuser=1&quot; alt=&quot;Observer&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="OOSE" scheme="https://InkyChew.github.io/categories/Notes/OOSE/"/>
    
    
      <category term="Design pattern" scheme="https://InkyChew.github.io/tags/Design-pattern/"/>
    
      <category term="Java" scheme="https://InkyChew.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>遞迴與迴圈</title>
    <link href="https://InkyChew.github.io/recursion/"/>
    <id>https://InkyChew.github.io/recursion/</id>
    <published>2020-12-11T04:29:27.000Z</published>
    <updated>2020-12-14T14:12:55.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遞迴-Recursion"><a href="#遞迴-Recursion" class="headerlink" title="遞迴 Recursion"></a>遞迴 Recursion</h1><p>以求N的階乘為例<br>fac(1) = 1<br>fac(N) = N * fac(N-1)</p><h2 id="內涵式遞迴-Embedded-recursion"><a href="#內涵式遞迴-Embedded-recursion" class="headerlink" title="內涵式遞迴 Embedded recursion"></a>內涵式遞迴 Embedded recursion</h2><ul><li>最後一個函式fac(1)呼叫完成後，一層層<strong>由內而外回傳</strong>數值並計算。</li><li>階層式架構</li></ul><a id="more"></a><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-comment">// 設定終止條件</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">    <span class="hljs-keyword">return</span> n * fac(n-<span class="hljs-number">1</span>); <span class="hljs-comment">// 控制變數 n，使其接近終止值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>fac(3)<br>return 3 * <code>fac(3-1)</code>       // n=3<br>return 3 * <code>2 * fac(2-1)</code>    // n=2<br>return 3 * 2 * <code>1 * fac(1)</code>   // n=1  </p><h2 id="尾端式遞迴-Tail-recursion"><a href="#尾端式遞迴-Tail-recursion" class="headerlink" title="尾端式遞迴 Tail recursion"></a>尾端式遞迴 Tail recursion</h2><ul><li>增加一個參數(ans)，紀錄累乘值。</li><li>平的架構</li></ul><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-comment">//設定終止條件</span></span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">    <span class="hljs-keyword">return</span> fac(n-<span class="hljs-number">1</span>, ans*n); <span class="hljs-comment">// 控制變數 n，使其接近終止值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>fac(3, 1)<br>return fac(2, 1*3)<br>return fac(1, 3*2)<br>return fac(0, 6*1)  </p><p>可以將尾端式遞迴轉換成While迴圈</p><h1 id="迴圈-Loop"><a href="#迴圈-Loop" class="headerlink" title="迴圈 Loop"></a>迴圈 Loop</h1><ol><li>將尾端式遞迴的終止條件，以not的形式當作while的進行條件。</li><li>將參數的變動放在迴圈中，必須先累乘，才將n-1。</li></ol><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 設定進行條件</span></span><br><span class="line">    ans = ans * n;</span><br><span class="line">    n--; <span class="hljs-comment">// 控制變數 n，使迴圈得以停止</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;遞迴-Recursion&quot;&gt;&lt;a href=&quot;#遞迴-Recursion&quot; class=&quot;headerlink&quot; title=&quot;遞迴 Recursion&quot;&gt;&lt;/a&gt;遞迴 Recursion&lt;/h1&gt;&lt;p&gt;以求N的階乘為例&lt;br&gt;fac(1) = 1&lt;br&gt;fac(N) = N * fac(N-1)&lt;/p&gt;
&lt;h2 id=&quot;內涵式遞迴-Embedded-recursion&quot;&gt;&lt;a href=&quot;#內涵式遞迴-Embedded-recursion&quot; class=&quot;headerlink&quot; title=&quot;內涵式遞迴 Embedded recursion&quot;&gt;&lt;/a&gt;內涵式遞迴 Embedded recursion&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最後一個函式fac(1)呼叫完成後，一層層&lt;strong&gt;由內而外回傳&lt;/strong&gt;數值並計算。&lt;/li&gt;
&lt;li&gt;階層式架構&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="Java" scheme="https://InkyChew.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>物件導向的五大原則</title>
    <link href="https://InkyChew.github.io/oo-principle/"/>
    <id>https://InkyChew.github.io/oo-principle/</id>
    <published>2020-12-10T01:32:08.000Z</published>
    <updated>2020-12-23T11:34:10.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SOLID-原則"><a href="#SOLID-原則" class="headerlink" title="SOLID 原則"></a>SOLID 原則</h1><h2 id="1-SRP-Single-Responsibility-Principle"><a href="#1-SRP-Single-Responsibility-Principle" class="headerlink" title="1. SRP (Single Responsibility Principle)"></a>1. SRP (Single Responsibility Principle)</h2><blockquote><p>一個class只對一種role(actor)負責。</p></blockquote><a id="more"></a><p>以電子支付為例，使用者可以收付款項。建立一個User class，包含收錢與付錢兩個方法。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"收錢"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"付錢"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>當userA要付錢給userB，我們可能會這麼寫<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(string[] args)</span> </span>&#123;</span><br><span class="line">  User userA = <span class="hljs-keyword">new</span> User();</span><br><span class="line">  User userB = <span class="hljs-keyword">new</span> User();</span><br><span class="line">  userA.pay();</span><br><span class="line">  userB.receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<a href="https://medium.com/@f40507777/%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC%E5%8E%9F%E5%89%87-single-responsibility-principle-7b4eb03f1fff" target="_blank" rel="noopener">作者Finn-SRP</a>這篇文章中提到:</p><blockquote><p>如果兩個方法的連動永遠都是同時變化，那就不必分離，否則可能造成不必要的複雜性。</p></blockquote><p>提醒我們需避免過度優化，將功能切割的過於細小，而使程式過於複雜。</p><p>上面的程式似乎符合同時的連動與變化，還算容易理解與維護，但功能增加或需要修改時，可能就不太理想了。<br>我們試著增加一些功能: 收款方，顯示QRcode，付款方掃描並驗證其QRcode後，輸入支付金額。收款方確認支付金額無誤後，才完成交易。並且雙方在交易完成後都能有現金5%的回饋。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.showQRcode();</span><br><span class="line">    <span class="hljs-keyword">this</span>.verifyInputMoney();</span><br><span class="line">    <span class="hljs-keyword">this</span>.cashBonus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQRcode</span><span class="hljs-params">()</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyInputMoney</span><span class="hljs-params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.openCamera();</span><br><span class="line">    <span class="hljs-keyword">this</span>.verifyQRcode();</span><br><span class="line">    <span class="hljs-keyword">int</span> money = scanner.NextInt();</span><br><span class="line">    <span class="hljs-keyword">this</span>.cashBonus();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openCamera</span><span class="hljs-params">()</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyQRcode</span><span class="hljs-params">()</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cashBonus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    balance = balance + money*<span class="hljs-number">5</span>%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若今天將政策改成付款方享有10%的現金回饋，而收款方現金回饋5%保持不變，問題就浮現了。</p><p>User class中的方法，同時對兩個actor負責。一個是付款方(payer)，另一個是收款方(payee)。因此建立兩個新的class，並將method切割出來，以實現RSP原則(一個class只對一個actor負責)。也能避免日後需求改變，修改方法(cashBonus)時，更動到其他角色應該有的正確行為。<br><code>RSP原則，提高class的cohesion，使其易於維護與修改。</code></p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payee</span></span>&#123; <span class="hljs-comment">// 收款方</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.showQRcode();</span><br><span class="line">    <span class="hljs-keyword">this</span>.verifyInputMoney();</span><br><span class="line">    System.out.println(<span class="hljs-string">"收錢"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQRcode</span><span class="hljs-params">()</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyInputMoney</span><span class="hljs-params">()</span></span>&#123;...&#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cashBonus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    balance = balance + money*<span class="hljs-number">5</span>%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payer</span></span>&#123; <span class="hljs-comment">// 付款方</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.openCamera();</span><br><span class="line">    <span class="hljs-keyword">this</span>.verifyQRcode();</span><br><span class="line">    <span class="hljs-keyword">int</span> money = scanner.NextInt();</span><br><span class="line">    System.out.println(<span class="hljs-string">"付錢"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openCamera</span><span class="hljs-params">()</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyQRcode</span><span class="hljs-params">()</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cashBonus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    balance = balance + money*<span class="hljs-number">10</span>%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-OCP-Open-Closed-Principle"><a href="#2-OCP-Open-Closed-Principle" class="headerlink" title="2. OCP (Open-Closed Principle)"></a>2. OCP (Open-Closed Principle)</h2><p>在設計已經完整的前提下，修改程式的兩個主要原因為:  </p><ol><li>增加新功能</li><li>修正問題(bugs)  </li></ol><p>若修改程式是為了<strong>增加新功能</strong>，就必須符合OCP原則。</p><ul><li>Open for extension 開放擴充</li><li>Closed for modification 避免修改</li></ul><p>達成OCP的方式:  </p><ol><li>Abstract class  </li><li>Interface   </li><li>Decorator  </li><li>Strategy  </li><li><a href="#5-DIP-Dependency-Inversion-Principle"><strong>DIP</strong></a></li></ol><h2 id="3-LSP-Liskov-Substitution-Priniple"><a href="#3-LSP-Liskov-Substitution-Priniple" class="headerlink" title="3. LSP (Liskov Substitution Priniple)"></a>3. LSP (Liskov Substitution Priniple)</h2><blockquote><p>Subtypes must be substitutable for their base types.  </p></blockquote><p>所有的subclass必須能夠在不破壞/不修改程式的情況下，使用parent class中的所有方法。</p><p>在實作OCP的同時，必須符合LSP。<br>以下為違反LSP的例子:<br>以哺乳類為例，除少數哺乳類，例如:鴨嘴獸(platypus)是卵生，其餘皆為胎生。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mammal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveBirth</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 直接生下胎兒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Platypus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mammal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layegg</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 產卵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>class Platypus 無法使用class Mammal中的giveBirth method ，違反LSP原則。</p><p>extends 為 IS-A 的關係<br>Platypus cannot giveBirth. Thus, Platypus is not a Mammal, Platypus cannot extend Mammal.  </p><p>透過<a href="https://docs.oracle.com/cd/E19683-01/806-7930/assert-13/index.html" target="_blank" rel="noopener">Design by Contract</a>來避免違反LSP:</p><ol><li>preconditions</li><li>postconditions</li><li>class invariants  </li></ol><p>Subclasses need to follow these rules:</p><ol><li>Don’t implement any stricter validation rules on input parameters than implemented by the parent class.<br>父類別的條件要比子類別嚴格</li><li>Apply at the least the same rules to all output parameters as applied by the parent class.</li></ol><h2 id="4-ISP-Interface-Segregation-Principle"><a href="#4-ISP-Interface-Segregation-Principle" class="headerlink" title="4. ISP (Interface Segregation Principle)"></a>4. ISP (Interface Segregation Principle)</h2><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.</p></blockquote><p>以遙控器為例:<br>電視遙控器可以開，關，預錄節目。<br>冷氣遙控器可以開，關，設定溫度。<br>可以發現電視遙控器並不需要設定溫度的功能，冷氣遙控器並不需要預錄節目的功能。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RemoteControl</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">record</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>為了預防 Bloated Interface，透過ISP原則，將Interface進行切割。<br>我們建立兩個新的Interface，TVRemote與AirConditionerRemote，將電視與冷氣個別會用到的功能切割出去。interface RemoteControl則保留最基本的遙控器開關功能。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TVRemote</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChannel</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">record</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AirConditionerRemote</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTemperature</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RemoteControl</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ISP與SRP相似，主張Class或Interface<strong>不應該包含多種用不到的或不相關的責任</strong>。避免需求改變時，因程式修改所產生的負面影響。因此將Class或Interface切割，雖然Class或Interface的數量增加，但cohesion提高。<br>兩者之間的差異:  </p><ul><li>ISP避免<strong>Interface</strong>包含了client用不到的method</li><li>SRP避免一個<strong>Class</strong>負責不同的角色</li></ul><h2 id="5-DIP-Dependency-Inversion-Principle"><a href="#5-DIP-Dependency-Inversion-Principle" class="headerlink" title="5. DIP (Dependency Inversion Principle)"></a>5. DIP (Dependency Inversion Principle)</h2><blockquote><p>High-level modules should not depend on low-level modules. <strong>Both should depend on abstractions.</strong><br>Abstractions should not depend on details. Details should depend on abstractions.</p></blockquote><p>切割兩個Class之間的依賴關係，建立一個新的抽象介面(Abstraction)，讓Class更容易<code>擴充</code>(OCP)，同時也必須遵守(LSP)。只要持續且正確的應用OCP與LSP，將會符合DIP。<br>splits the dependency between the high-level and low-level modules by introducing an abstraction between them. So in the end, there are two dependencies:</p><ol><li>the high-level module depends on the abstraction, and</li><li>the low-level depends on the same abstraction.</li></ol><p>以Airplane為例，飛機可以在跑道上跑(run)，也可以飛到空中(fly)。Jet依賴於Airplane的run和fly功能，並且可以射擊(shoot)與防禦(defend)。<br><img src="https://upload.cc/i1/2020/12/14/R8K2Zq.jpg" alt="Before"><br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span> <span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jet</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> Airplane airplane</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    airplane.run();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    airplane.fly();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shoot</span> <span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defend</span> <span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>為了<strong>降低coupling</strong>(減少class之間的依賴關係)，並讓功能容易擴充避免修改(<strong>OCP</strong>)，建立Interface AirplaneAction，讓Airplane和Jet可以實作run和fly。由於Airplane並不能shoot和defend，因此新增一個軍備的Interface Arms，讓Jet實作shoot和defend，以遵守<strong>LSP</strong>。</p><p><img src="https://upload.cc/i1/2020/12/14/sF6TPy.jpg" alt="After"></p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://www.thinkinmd.com/post/2020/03/06/oo-single-responsibility-principle/" target="_blank" rel="noopener">SRP</a><br><a href="http://teddy-chen-tw.blogspot.com/2011/12/2.html" target="_blank" rel="noopener">OCP</a><br><a href="https://medium.com/@f40507777/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-adc1650ada53" target="_blank" rel="noopener">LSP</a><br><a href="https://stackify.com/interface-segregation-principle/" target="_blank" rel="noopener">ISP</a><br><a href="http://teddy-chen-tw.blogspot.com/2012/01/5dependency-inversion-principle.html" target="_blank" rel="noopener">DIP</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SOLID-原則&quot;&gt;&lt;a href=&quot;#SOLID-原則&quot; class=&quot;headerlink&quot; title=&quot;SOLID 原則&quot;&gt;&lt;/a&gt;SOLID 原則&lt;/h1&gt;&lt;h2 id=&quot;1-SRP-Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#1-SRP-Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;1. SRP (Single Responsibility Principle)&quot;&gt;&lt;/a&gt;1. SRP (Single Responsibility Principle)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一個class只對一種role(actor)負責。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
      <category term="OOSE" scheme="https://InkyChew.github.io/categories/Notes/OOSE/"/>
    
    
      <category term="OOSE" scheme="https://InkyChew.github.io/tags/OOSE/"/>
    
  </entry>
  
  <entry>
    <title>物件導向的三大特性和抽象化</title>
    <link href="https://InkyChew.github.io/oo-basic/"/>
    <id>https://InkyChew.github.io/oo-basic/</id>
    <published>2020-12-09T13:21:01.000Z</published>
    <updated>2021-04-03T06:21:39.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="1-封裝-Encapsulation"><a href="#1-封裝-Encapsulation" class="headerlink" title="1. 封裝 (Encapsulation)"></a>1. 封裝 (Encapsulation)</h2><p>將attribute(variable)與method打包成一個class，以隱藏實作細節，提高資料完整性。其他的class只能透過method(setter/getter)修改/取得variable的值。</p><ul><li>private variable</li><li>public method</li></ul><a id="more"></a><h2 id="2-繼承-Inheritance"><a href="#2-繼承-Inheritance" class="headerlink" title="2. 繼承 (Inheritance)"></a>2. 繼承 (Inheritance)</h2><ul><li>父類別(superclass)</li><li>子類別(subclass)  </li><li>subclass inherit superclass</li></ul><p>將多個相同性質的子類別，擷取出共有的特徵，並將這些共有特徵定義成一個父類別，讓子類別可以繼承。避免subclass重複定義相同的attribute與method。</p><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="hljs-keyword">int</span> age;</span><br><span class="line">  Animal (String name, <span class="hljs-keyword">int</span> age) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span> <span class="hljs-params">(String food)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"I want to eat "</span> + food);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  Dog (String name, <span class="hljs-keyword">int</span> age) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="覆寫-overriding"><a href="#覆寫-overriding" class="headerlink" title="覆寫 (overriding)"></a>覆寫 (overriding)</h3><ul><li>方法名稱，回傳型態，參數必須相同。</li><li>subclass的方法，覆寫superclass的方法。有兩個class。</li><li>subclass可以針對其特定需求覆寫superclass的方法，讓設計更為彈性。  </li></ul><p>Dog.eat override Animal.eat<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"I am not hungry!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"Bones!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="過載-overloading"><a href="#過載-overloading" class="headerlink" title="過載 (overloading)"></a>過載 (overloading)</h3><p>在<strong>同一個class</strong>裡，定義了<strong>相同名稱</strong>但是<strong>結構不同</strong>的方法。<br>例如: 回傳型態不同，參數不同。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"I am not hungry!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span> <span class="hljs-params">(String food)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"I want to eat "</span> + food);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-多型-Polymorphism"><a href="#3-多型-Polymorphism" class="headerlink" title="3. 多型 (Polymorphism)"></a>3. 多型 (Polymorphism)</h2><p>同一個方法，有不同的行為。</p><ul><li>override</li><li>interface</li></ul><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Interface Animal &#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"Bones!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"Fish!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Abstraction-抽象化"><a href="#Abstraction-抽象化" class="headerlink" title="Abstraction (抽象化)"></a>Abstraction (抽象化)</h1><p>隱藏實作細節，只提供可用功能給使用者。</p><h2 id="Abstract-Class"><a href="#Abstract-Class" class="headerlink" title="Abstract Class"></a>Abstract Class</h2><ul><li>有abstract method 的 class 即為 Abstract class。也可以包含有body實作的concrete method。</li><li>不能夠create(new)，必須被子類別繼承後才能透過子類別create。</li><li>abstract method: 沒有body的method。必須透過子類別加以實作行為。</li></ul><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// abstract method</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// concrete method</span></span><br><span class="line">    System.out.println(<span class="hljs-string">"I am not hungry!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><ul><li>集結相關的abstract method。</li><li>只有abstract method。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interface Animal &#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三大特性&quot;&gt;&lt;a href=&quot;#三大特性&quot; class=&quot;headerlink&quot; title=&quot;三大特性&quot;&gt;&lt;/a&gt;三大特性&lt;/h1&gt;&lt;h2 id=&quot;1-封裝-Encapsulation&quot;&gt;&lt;a href=&quot;#1-封裝-Encapsulation&quot; class=&quot;headerlink&quot; title=&quot;1. 封裝 (Encapsulation)&quot;&gt;&lt;/a&gt;1. 封裝 (Encapsulation)&lt;/h2&gt;&lt;p&gt;將attribute(variable)與method打包成一個class，以隱藏實作細節，提高資料完整性。其他的class只能透過method(setter/getter)修改/取得variable的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private variable&lt;/li&gt;
&lt;li&gt;public method&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://InkyChew.github.io/categories/Notes/"/>
    
    
      <category term="OOSE" scheme="https://InkyChew.github.io/tags/OOSE/"/>
    
  </entry>
  
  <entry>
    <title>軟體工程師有三種，你是哪一種?</title>
    <link href="https://InkyChew.github.io/engineer-3types/"/>
    <id>https://InkyChew.github.io/engineer-3types/</id>
    <published>2020-12-02T07:36:55.000Z</published>
    <updated>2020-12-23T11:36:02.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><ol><li>了解軟體工程師的種類與職涯發展方向。</li><li>成為一名優秀的軟體工程師所需技能。</li><li>軟體工程師可依照思維區分為三種類型。</li></ol><a id="more"></a><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>在文章<a href="https://wei729.pixnet.net/blog/post/17798907" target="_blank" rel="noopener">剖析IT人員工作種類</a>中，可以大致瞭解IT領域人員的各個職稱與工作內容。再依照自身的興趣，選定想走的方向，並到人力銀行使用關鍵字進行搜索，進而了解並整理出各個職位的必備技能，以供未來進修學習的方向。以下為我有興趣的職位:</p><h2 id="研究開發人員-RD"><a href="#研究開發人員-RD" class="headerlink" title="研究開發人員(RD)"></a>研究開發人員(RD)</h2><h3 id="軟體工程師"><a href="#軟體工程師" class="headerlink" title="軟體工程師"></a>軟體工程師</h3><ol><li>前端</li><li>後端  </li><li>DevOps</li></ol><h3 id="系統分析師"><a href="#系統分析師" class="headerlink" title="系統分析師"></a>系統分析師</h3><ul><li>程式撰寫前進行規劃與設計。  </li><li>使用者與開發團隊間的溝通橋樑。  </li><li>須具備多年程式設計經驗。</li></ul><h2 id="軟體工程師的三種類型"><a href="#軟體工程師的三種類型" class="headerlink" title="軟體工程師的三種類型"></a>軟體工程師的三種類型</h2><p>可依照思維區分為:</p><h3 id="1-Coder"><a href="#1-Coder" class="headerlink" title="1. Coder"></a>1. Coder</h3><p>對於被交付的任務，只求盡快且輕鬆的完成工作。也就是老闆說什麼，就做什麼。不質疑功能的好壞，不提出更好的想法以優化產品。寫程式時看重輸入、輸出與結果。產品只是所有功能的結合，很可能不符合使用者需求。企業若想開發出好產品，必須要有很厲害的PM與PD。</p><h3 id="2-Hacker"><a href="#2-Hacker" class="headerlink" title="2. Hacker"></a>2. Hacker</h3><p>Know and do 和 Don’t know and do 這兩類型的人都可以稱為 Hacker。因此 Hacker 也被稱為 Doer。Hacker一詞，在字典上有兩個解釋，分別為: </p><ol><li>寫程式和解決問題的專家。 (Know and do)</li><li>沒有技能或天賦而投入於活動中的人。  (Don’t know and do)</li></ol><p><strong>為什麼做?</strong> 對Hacker而言很重要，他們致力於打造好用且創新的產品。因此提出更好的想法以優化產品，思考產品是否有用?是否能符合需求?</p><h3 id="3-Architect"><a href="#3-Architect" class="headerlink" title="3. Architect"></a>3. Architect</h3><p>寫程式時看重架構、優化、成本、格局。持續的學習、思考、質疑、創造。用Geek來稱呼這些人也不為過!他們擁有兩大特徵:</p><ol><li>喜歡有秩序，可以重複使用且永久保存的code</li><li>樂於分享</li></ol><p>他們致力於開創新系統、新套件、新框架，將複雜重複的流程打包以簡化流程，並無私的分享給世界，對於IT領域有很大的貢獻。例如: Linux, Open source 。</p><h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><p>期許自己在軟體工程師的職涯中，永遠當一個Hacker，並朝著Architect之路邁進。雖然寫code的功力還遠遠不足，但我可以一直是個分享者Giver，持續的學習並分享。</p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ol><li><a href="https://betweengos.com/career-3-types-of-programmer-coder-hacker-architect/" target="_blank" rel="noopener">如果妳也開始學寫Code－依個性分類，會是哪種程式設計師？</a>  </li><li><a href="https://wei729.pixnet.net/blog/post/17798907" target="_blank" rel="noopener">剖析IT人員工作種類</a></li><li><a href="https://dennis74728.pixnet.net/blog/post/13012312" target="_blank" rel="noopener">SA,SD與SE</a></li><li><a href="https://tw.twincl.com/programming/*652e" target="_blank" rel="noopener">程式員求生指南：關於寫程式的二三事</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;了解軟體工程師的種類與職涯發展方向。&lt;/li&gt;
&lt;li&gt;成為一名優秀的軟體工程師所需技能。&lt;/li&gt;
&lt;li&gt;軟體工程師可依照思維區分為三種類型。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Reflection" scheme="https://InkyChew.github.io/categories/Reflection/"/>
    
    
      <category term="reflection" scheme="https://InkyChew.github.io/tags/reflection/"/>
    
  </entry>
  
</feed>
