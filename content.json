{"pages":[{"title":"About Me","text":"周郁穎 Inky 8th March, 1999 Taichung, Taiwan 雲林科技大學 資訊管理系 inky11308@gmail.com 程式技能 Vue.js, Flask, Bootstrap HTML, Pug, SCSS JavaScript, PHP, Java, Python, SQL 語言能力 TOEFL iBT 80 TOEIC 825 全民英檢 中級","link":"/about/index.html"}],"posts":[{"title":"Sorting algorithm - Bubble sort","text":"Bubble sort 氣泡排序法 每一次比較兩個相鄰數值，如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置。因為已經確保最大數值的位置，因此下一次需要比較的數值會少一個。 將以上的敘述拆解: 每一次比較兩個相鄰元素思考要比較幾次?假設有五個數值，兩兩相比需比較四次。我們可以用arr.length-1表示。 兩相鄰元素比較次數 = 總元素數量-1 下一次需要比較的元素會少一個第0次比較兩個相鄰元素，( 總元素數量-0 )-1個數值第1次比較兩個相鄰元素，( 總元素數量-1 )-1個數值第2次比較兩個相鄰元素，( 總元素數量-2 )-1個數值…第i次比較兩個相鄰元素，arr.length-i-1個數值 如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置 123456789for (int i = 0; i &lt; arr.length-1; i++) &#123; // 1. for (int j = 0; j &lt; arr.length-i-1; j++) &#123; // 2. if (arr[j] &gt; arr[j+1]) &#123; // 3. int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125;&#125; Time complexity: O(n*n)上述的程式碼缺乏效率，儘管陣列中所有的元素都已經排序完成，程式依然執行n*n次。 觀察下方的圖片幫助理解我們可以發現執行第6次時就已經完成排序，但卻執行了10次 Optimized implementation如何知道所有的元素已經排序完成?當兩相鄰元素的交換不再發生時，即完成所有元素的排序 1234567891011121314151617181920for (int i = 0; i &lt; arr.length-1; i++) &#123; boolean swapped = false; for (int j = 0; j &lt; arr.length-i-1; j++) &#123; if (arr[j] &lt; arr[j+1]) &#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; // 當有交換發生時，將swapped設成true swapped = true; &#125; &#125; // 當兩相鄰元素的交換不再發生時 // 所有元素排序完成 if (swapped == false) break;&#125; Time complexityWorst case: O(n*n)所需執行時間的最壞情況，發生在陣列當中的元素以反向排序時Best case: O(n)所需執行時間的最佳情況，發生在陣列當中的元素已經排序好時 參考資料geeksforgeeks-Bubble sort[演算法] 氣泡排序法 Bubble Sort","link":"/algo-sort-bubble/"},{"title":"TodoList","text":"A To-do-list create by Vue.js. https://github.com/InkyChew/Vue.js_todolist body中引入vue.js&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; Directivev-model 資料雙向綁定v-on methodv-ifv-forv-focus 自訂directive，防止多個 li 因 v-model 綁定同時修改 1234567directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125;, v-bind:class=&quot;{&#39;completed&#39; : todo.completed}&quot;use completed class ， when todo.completed == true :class 無法使用data綁定class:style 可使用data綁定class 配置方式 123456var app = new Vue(&#123; el:&apos;&apos;, //綁定最外層要素 data: &#123;&#125;, //綁定 v-model 資料 computed:&#123;&#125;, //即時更新的運算資料 methods: &#123;&#125;&#125;) 參考資料https://peterhpchen.github.io/VuejsQuest/basic/06_Directives.html#%E4%BB%8B%E7%B4%B9https://quip.com/M2eCAQo6bXh8https://vuejs.org/v2/guide/installation.html","link":"/TodoList/"},{"title":"Time Complexity","text":"在寫程式時，同一個問題，可以有多個不同的解法，因此我們需要衡量不同方法的時間與空間複雜度，以找到最佳的解法。在現代，儲存空間已經不是太大的問題，因此我們關注程式的效率，也就是演算法的時間複雜度(Time Complexity)。 Time Complexity 時間複雜度隨著輸入資料量的增加，執行時間的變化使用Asymptotic Notation表示時間複雜度。 Asymptotic Notation 漸近符號 Big-O ( Ο ): 以Ο()表示演算法所需執行時間的最壞情況 Omega ( Ω ): 以Ω()表示演算法所需執行時間的最佳情況 Theta ( θ ): 以θ()表示演算法所需執行時間的範圍，包含了最壞與最佳情況 時間複雜度所需執行時間，由短到長:1(常數) &lt; log n &lt; n &lt; n log n &lt; n^2 &lt; 2^n &lt; n! 以Big-O表示時間複雜度的四種常見類型1. Constant Run Time (O(1))不管資料量大小，執行時間都一樣。 12345678var arr = [1,2,3,4,5]var arr2 = [1,2,3,4,5,6,7,8,9,10]function constant(arr) &#123; console.log(arr[0]);&#125;// 不管傳入arr或arr2，執行次數皆為一次。 2. Logarithmic Run Time (O(log n))隨著資料量增加，執行時間趨緩。 123456789while(n &gt; 0) &#123; n = n / 2;&#125;/** var n = 10 * n -&gt; 10, 5, 2, 1, 0 * var n = 15 * n -&gt; 7, 3, 1, 0 **/ 3. Linear Run Time (O(n))隨著資料量增加，執行時間成線性等比例成長。12345for(int i = 0; i &lt; n; i++) &#123; ...&#125;// 執行次數為n次 4. Exponential Run Time (O(n^2))隨著資料量增加，執行時間成指數成長。 1234567for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; ... &#125;&#125;// 執行次數為n*n次 參考資料[演算法] Big O and Time Complexity[演算法] Big O Notation &amp; Time Complexity","link":"/algo-timeComplexity/"},{"title":"Sorting algorithm - Insertion sort","text":"Insertion sort 插入排序法將資料分成已排序(sorted)與未排序(unsorted)兩部分，依序取出未排序部分的第一個數值(目標值)，將其插入到已排序部分當中的正確位置。將目標值由右向左依序與已排序部分中的數值進行比較，當已排序部分中的數值大於目標值則往右移一個位置，否則將目標值插入。 將以上的敘述拆解: 依序取出未排序部分的第一個數值(目標值) 將目標值由右向左依序與已排序部分中的數值進行比較 當已排序部分中的數值大於目標值則往右移，否則將目標值插入。 123456789for (int i = 1; i &lt; arr.length; i++) &#123; // 1. int target = arr[i]; int j = i-1; // 2. while (j &gt;= 0 &amp;&amp; arr[j] &gt; target) &#123; // 3. arr[j+1] = arr[j]; j--; &#125; arr[j+1] = target;&#125; Time complexityWorst case: O(n*2)Best case: O(n) 適合在資料幾乎已經排序完成或資料量很小的時候使用 參考資料geeksforgeeks-Insertion sort","link":"/algo-sort-insertion/"},{"title":"Algorithm","text":"演算法 (Algorithm) 解決問題的流程 滿足五條件 輸入 可有可無 輸出 至少要有一個 有限性 有限步驟內解決問題 明確性 步驟清楚明確、條理分明 有效性 必須能夠解決問題 表示方式 Psuedo code Flow chart 演算法系列文章時間複雜度（Time Complexity）&amp; big-O空間複雜度 資料結構的各項操作 排序（Sorting）： Bubble sort O(n*n) Insertion sort O(n*2) Quick sort Merge sort O(n logn) 搜尋（Searching） Depth-first-search Breadth-first-search Binary search 遞迴（recursive）分治法（divide and conquer）迭代（iteration）","link":"/algo/"},{"title":"AWS Core Services - Network","text":"VPCVirtual Private Network，必定架構在一個Region當中，一個帳戶可以擁有多個VPC，多個VPC之間彼此獨立。透過Subnet切割VPC，以允許VPC跨越多個Availability Zone。 Network configuration IP address range每一個VPC都有一個特定的IPv4位址(32bit)。ex: 10.0.0.0/x (16&lt;=x&lt;=28 bit)/16 32-16=16，有216個IP位址可使用/20 32-20=12，有212個IP位址可使用/28 32-28=4，有24個IP位址可使用 EIP (Elastic IP) Address: 將一個EIP Address與一個EC2 Instance連結(綁在一起)，VPC(為Private IP)即可使用此Public IP address對外連接。 Subnet切割VPC的IP address range。ex: 10.0.0.0/20 (default) 一個Availability zone當中可以有多個Subnets。也就是，一個Subnet對應一個Avaliability Zone，但不可以橫跨Availability Zone。 Types public : 透過Internet的連接使Subnet彼此互相連通 private : Subnet彼此不互相連通 VPN only (Virtual Private Network) : 完全只使用公司內部的網路連接 Route table控制流出Subnet的流量，控制Subnet的流向。ex: 禁止Subnet通往Internet。 Network gateway IGW (Internet Gateway) : 允許VPC與Internet連接。讓外面的Network透過Internet連進VPC，讓外面連進來。 NAT (Network Address Translation) Instances &amp; Gateway不想讓外面連進來，但想連出去，透過NAT將Private轉成Public。由自己管理的服務稱為Instances，由AWS管理的服務的稱為Gateway。 Endpoint當不想使用IGE或NAT時，可以使用Endpoint直接與AWS的服務連接。 Peering允許兩個不同Region的VPC互相連接。 Security Security groups : EC2 Instances的虛擬防火牆，有狀態的 ACLs (Network Access Control Lists) : Subnets的防火牆，控制Sebnet的存取，無狀態的 Connection Hardware VPN Direct Connect : 專用的私有連接 VPN CloudHub : 透過VPC，與多個VPN連接，多個VPN彼此可以互相連通。 Software VPN Security groupsSecurity groups是一個虛擬的防火牆(virtual firewall)。一個Security group可以有多個EC2 Instances，也就是說，多個EC2 Instances可以共用一個防火牆的設定。Security group可以跨Subnets，不同的Subnets中的EC2 Instances可以共用同一個防火牆設定。 Key pairs為從Firewall外部連接進來時，加解密login資訊的密碼學技術。Linux : SSHWindows : RDP (Remote Desktop) Cloud Front連線先後順序 : Edge Location &lt; Edge Location Cache &lt; VPC若先前連線的位置有資源時，即取得；若無資源，則從後一個位置取得資源。","link":"/aws-network/"},{"title":"AWS Core Services - Compute","text":"EC2Elastic Compute Cloud，在雲端上提供虛擬的Computing環境。此虛擬環境稱為Instances。 依照對資源不同的需求區分成四種方案: On-Demand適合短期的、高峰的或不可預測的工作量，例如應用程式的測試與開發。成本高(3)，資源最少要使用60秒。 Spot InstancesAmazon釋出閒置資源，讓顧客以競標的方式取得，因此取得資源的成本低(1)。但是資源有隨時被Amazon收回的風險，適合起始與結束時間彈性的應用。透過Hibernation在資源被取回時暫時休眠，並在取回資源時重啟Instances。 Reserved Instance向Amazon預定1年或3年的資源，成本較低(2)。適合清楚資源需求的應用或災難發生時的預備資源。 Dedicated Host向Amazon取得一台專用的主機，以遵守商業、政府的規定。 Cost optimization Right sizing選擇適合的Instance type，並透過CloudWatch監管以衡量流量，縮減Instances的數量。 Reserved Instances Increase elasticity使用流量小的Instances，可以增加彈性。由下圖可以了解，流量大的Instances會在需求不多時造成浪費。 Monitor &amp; Improve AMIAmazon Machine Image，為初始化Instance的軟體。當Instance啟用的時候，AMI將佈署使用EC2提供的服務並定義作業系統，修補程式的初始狀態和應用/系統軟體。 AMI lifecycle and uses ELBElastic Load Balancer (Balancing)，可以做為流量流入的單一窗口(single access point)，分散進入EC2 Instances的流量以提高容錯程度(fault tolerance)與可用性(availability)，增加彈性與可擴充性，且可以decouple application environement。Type: ALB (Application Load Balancer)掌管應用層(HTTP, HTTPs)的流量。 routing path-based https://webapp.yuntech.edu.tw/`YunTechSSO`https://webapp.yuntech.edu.tw/`WebNewCAS` - host-basedhttps://webapp.yuntech.edu.tw/https://webmail.yuntech.edu.tw/ - Dynamic port: 若有多個相同的port，會動態分配流量至閒置的port中。 NLB (Network Load Balancer)掌管傳輸層(TCP)的流量，分派速度快，適合在立即與變化快速的流量模式下使用。NLB可以跨AZ，每一個AZ會有一個static IP address。 Auto Scaling依照需求啟動/終止EC2 Instances，以調整EC2 Instances的數量，並自動地向ELB登記。當增加/減少EC2 Instances時，ELB必須知道，如此ELB才能正確的分派流量給各個Instances。 可以Scaling的資源包含: EC2 Instances、Spot Fleets、DynamoDB tables indexes、Aurora replicasSpot Fleets (競標艦隊): spot + on-demand Components以EC2 Instances為例 CloudWatch 用來追蹤資源的效能，監控EC2 Instances的流量。 蒐集log files加以分析做為資源方案選擇，條件設定時的依據。 當條件被觸發時透過alarm/event的通知採取行動。 ELB、CloudWatch、Auto Scaling 間的關係與互動Cloud watch蒐集流量資料加以衡量，達到特定條件出發alarm啟動Auto Scaling以增減EC2 Instances，並告知ELB，EC2 Instances的增減變化。 Lambda完全不須管理伺服器，以0.1秒計價，執行時間不得超過5分鐘。 Elastic BeanstalkPlatform as a Service，快速佈署、縮放、管理 web apps。","link":"/aws-compute/"},{"title":"Sorting algorithm - Merge sort","text":"Merge sort 重複將資料從中間切成左右兩半，直到切出來的每一半只剩下一個元素 由小到大合併左右兩半 新增左右兩半兩個陣列 比較左右兩半元素的大小，進行合併 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// divide(arr, 0, arr.length-1);public void divide(int arr, int l, int r) &#123; if (l &lt; r) &#123; int mid = (l+r) / 2; divide(arr, l, mid); divide(arr, mid+1, r); merge(arr, l, mid, r); &#125;&#125;public void merge(int arr, int l, int m, int r) &#123; // 新增左右兩半兩個陣列 l_size = m-l+1; r_size = r-m; int L[] = new int[l_size]; int R[] = new int[r_size]; // 將原陣列中的元素複製到左右陣列中 for(int i = 0; i &lt; l_size; i++) L[i] = arr[l+i]; for(int i = 0; i &lt; r_size; i++) R[i] = arr[m+1+i]; // 比較左右兩半元素的大小，進行合併 int i = 0, j = 0; int k = l; // 當&lt;左右兩半&gt;或&lt;其中一半&gt;沒有元素時，跳出迴圈 while (i &lt; l_size &amp;&amp; r &lt; r_size) &#123; if(L[i] &lt; R[j]) &#123; arr[k] = L[i]; i++; &#125; else &#123; arr[k] = R[j]; j++; &#125; k++; &#125; // 當左半還有元素時，將元素加入至合併陣列中 while(i &lt; l_size) &#123; arr[k] = L[i]; i++; k++; &#125; // 當右半還有元素時，將元素加入至合併陣列中 while(j &lt; r_size) &#123; arr[k] = R[j]; j++; k++; &#125;&#125; Time complexityWorst case: O(n logn)Best case: O(n logn)divide() = log n ; merge() = n 參考資料geeksforgeeks-Merge sort","link":"/algo-sort-merge/"},{"title":"AWS Core Services - Storage","text":"Block storage V.S. Object storage Block storage將資料儲存在一個個區塊(Block)中。當更改檔案中的某一個字元時，會找到該字元儲存的區塊進行修改，也就是說只修改檔案中的某一個區塊。 Object storage以Object為單位儲存。當更改檔案中的某一個字元時，會將整個檔案重新覆寫，修改整個檔案。一個檔案就是一個Object。 EBSElastic Block Storage，儲存方式為Block storage，提供一個EC2 Instance個別的儲存空間。 Volume TypesIOPS: Input Output Operations per Second Snapshots使用快照以建立一個新的EBS volume types S3Simple Storage Service，儲存方式為Object storage，可以無縫地立即地縮放資料，並可以觸發(trigger)事件。 Storage Classes Standard Standard-IA One Zone-IA Glacier IA: Infrequence Access 在Region中建立一個獨一無二的Bucket name，並將資料上傳到這個Bucket當中，AWS會自動備份資料到三個不同的Availability zone。 Glacier提供典藏的(有價值不能丟需要保存很久的)資料儲存的服務，安全可靠且低成本。 Lifecycle policies隨著時間移動資料到成本低的儲存類別 EFSElastic File System，儲存方式為File storage。儲存的資料可以共享，可提供多個EC2 Instances存取。 EBS 在建立 Volume後必須選擇 File system. ex: Linux, Windows… Mount target一個File system可以有多個Mount target，存在於同一個VPC中，且一個Subnet與一個Avaliability zone中只存在一個Mount target。","link":"/aws-storage/"},{"title":"C語言的那些事","text":"指標 Poiter指標存記憶體位址透過指標變數提取記憶位址宣告指標變數 型態 *名稱 12345678910111213141516171819202122int *num_p; /*宣告指標變數*/int num;num_p = &amp;num; /*讓指標變數num_p指向變數num的記憶體位址*/``` # Call by value```cvoid swap();int main(void) &#123; int x = 5, y = 10; swap(x, y);&#125;void swap(int a, int b) &#123; int temp; temp = a; a = b; b = temp;&#125; 將變數x、y的值傳給變數a、b。進行swap()之後，變數a、b的值改變，但變數x與y的值不變。 Call by reference&amp; 表變數的位址* 指標變數中，儲存位址所指向的值12345678910111213void swap();int main(void) &#123; int x = 5, y = 10; swap(&amp;x, &amp;y);&#125;void swap(int *a, int *b) &#123; int temp; temp = *a; *a = *b; *b = temp;&#125; 將變數x、y的記憶體位址傳給指標變數a、b。也就是說，使用指標變數a、b，儲存變數x、y的記憶體位址。進行swap()之後，指標變數a、b儲存的記憶體位址互換，因此變數x與y的值改變。","link":"/c-program/"},{"title":"Cloud computing","text":"Cloud computing是可以根據需求使用資訊科技服務的能力根據NIST(National Institute of Standards and Technology)的定義，Cloud computing必須符合下列5項條件: On-demand self-serviced可以根據需求自行取用服務。 Broad network access資源與服務可得的範圍很廣。 Resource pooling資源必須獨立區隔。例如公司A不能看到且不能存取公司B的資料，公司B也不能看到且不能存取公司A的資料。 Rapid elasticity可以立即增加或減少資源。 Measured service可衡量資源使用量(capacity)與提供資源的表現。 Delivery ModelsNIST依照服務如何被使用也就是使用者需要與多少層級的基礎計算服務互動定義3種cloud service Delivery Models: IaaS (Infrastructure as a Service)當需要符合特殊的政府、行業規定，或需要控制環境的各方面時使用。ex: virtual machine instances, block storage, virtual private network segments, virtual function network device (router, firewall…) PaaS (Platform as a Service)降低基礎設備的維護與複雜性。ex: database, email… SaaS (Software as a Service)ex: web browser, mobile, IoT applications Shared responsibility model區分provider與consumer間的責任 Deployment typesCloud Deployment types: Public Private可以自行架設或供應商提供組織內部自用的雲端環境，以遵守特殊的政府或行業規定。 Hybridpublic + private Community在特定社群中共享資源，多用在學術、政府、開源專案。 不同的Service Delivery Models可以源自不同的Deployment types，但必須符合Essential characteristics才能被視為Cloud computing。 在市場我們交易有形的產品或無形的服務，Cloud即為市場上的服務，可以大致區分成2種方案: rental on-demand 短租短期且需求有較高的不確定性時使用的方案 leasing reserved 長租長期且了解需求量時使用的方案 Virtualization and ContainersCloud computing高度仰賴Resource pooling，但現實中實體可得的硬體為一個大單位，因此必須透過Virtualization將一個硬體切割成多個邏輯單位，以獨立地提供不同的個別使用者在同一個資源上使用。因此我們說Virtualization是驅動Cloud computing的引擎。 一個virtual machine一定會有一個作業系統，透過Hypervisor區隔多個作業系統(多個tenants個別使用者)，且每一個作業系統會確保只有該tenants有對virtual machine instances內容的存取權。 Containers的概念與Virtualization相同，只是Containers比較小比較精實。Containers是一個package，包含一個application與其依賴的dependencies和configurations，但不包含作業系統。Containers並不包含作業系統，而是作業系統包含Containers，並透過Container engine (Manager)區隔多個Containers (App)。Containers間彼此獨立，但可以共享作業系統中的所有資源。","link":"/cloudComputing/"},{"title":"Data Structure - Graph & Network","text":"Graph圖形(Graph)由頂點(Vertics/Nodes)集合與邊(Edges)集合組成。G=(V,E)透過頂點儲存資料，透過邊表示頂點間的連通關係，依照有無方向性區分成&lt;有向圖&gt;與(無向圖)。 完全圖: 圖形中的每一個頂點皆與其他頂點相互連接。無向完全圖: |E| = N(N-1) / 2有向完全圖: |E| = N(N-1) 有向圖 (Directed Graph) 無向圖 (Undirected Graph) 分支度 (Degree) 有向圖 出分支度 (Out Degree) - 從該頂點指出去的箭頭數 入分支度 (In Degree) - 指向該頂點的箭頭數 頂點 出分支度 入分支度 1 1 1 2 2 1 3 1 2 4 1 1 無向圖 頂點 分支度 1 2 2 3 3 2 4 3 表示法相鄰矩陣 (Adjacent Matrix)若兩頂點互相連通則標示為1，否則標示為0。 有向圖 出分支度為列的總和 入分支度為行的總和 無向圖 此矩陣為一對稱矩陣，透過對稱矩陣中上或下三角形的部分即可表示無向圖。 分支度為列/行的總和 相鄰串列 (Adjacent List)在相鄰串列中的一節點(node)包含頂點欄(Vertex Field)與鏈結欄(Link Field)。 Vertex Field - 儲存非零元素的行值(頂點)Link Field - 指向同一列右邊非零元素的節點 有向圖 有向圖的相鄰串列表示某一頂點向外連接其他頂點的關係 出分支度為相鄰串列的長度 入分支度為反向相鄰串列的長度 無向圖 分支度為串列長度 圖形追蹤從某一頂點開始，尋訪其他所有可到達的頂點 方法: 深度優先搜尋法 DFS堆疊Ⅰ 將起始頂點設定為拜訪過，並輸出該頂點Ⅱ 選擇一與該起始頂點相鄰且尚未拜訪過的頂點Ⅲ 將該選擇頂點當成起始頂點重複搜尋直到所有頂點皆被拜訪過為止 1234567891011void dfs(int i) &#123; int j; int step = 0; visit[i] = visited; printf(\"step%d: visit v%d\\n\", ++step, i); for(j=0; j&lt;vertices; j++) if(adj_matrix[i][j]==1 &amp;&amp; visit[j]!=visited) dfs(j);&#125; 廣度優先搜尋法 BFS佇列Ⅰ 將起始頂點設定為拜訪過，並輸出該頂點Ⅱ 將所有與該起始頂點相鄰且尚未拜訪過的頂點加入queue的尾端Ⅲ 當queue不為空，取出queue最前端且尚未拜訪過的頂點Ⅳ 將該取出頂點當成起始頂點重複搜尋直到所有頂點皆被拜訪過為止 1234567891011121314151617 void bfs(int i) &#123; int j; int step = 0; visit[i] = visited; printf(\"step%d: visit v%d\\n\", ++step, i); for(j=0; j&lt;vertices; j++) &#123; if(adj_matrix[i][j]==1 &amp;&amp; visit[j]!=1) input_queue(j); // 將頂點加入queue的尾端 &#125; while(rear != front) &#123; // queue is not empty i = output_queue(); // 取出最前端的queue if(visit[i] != visited) bfs(i); &#125;&#125; 擴張樹 (Spanning Tree)基本特性: 不允許迴路(Cycle)存在 必有一條路徑連接任兩頂點 |E| = |V| - 1擴張樹的邊 = 頂點數 - 1 Network網路(Netework)為在邊(Edge)上加上成本/權重(weight)的圖形。依照有無方向性區分成有向網路與無向網路。 花費最小成本擴張樹花費最小成本擴張樹(Minimum Cost Spanning Tree)為擁有最小邊集合總成本的擴張樹，但兩頂點間的成本不一定是最小的。建立方法: Prim’s Method - 循序加入頂點 Kruskal’s Method - 循序加入邊 單一頂點到其他頂點之最短距離【有向網路】從一起始頂點到其餘每一頂點的最短距離 定義distance[]為儲存起始頂點到其餘每一頂點最短距離的矩陣定義selected[]為儲存頂點是否被選擇的矩陣 Ⅰ 初始化distance與selected，將起始頂點到其餘每一頂點的最短距離儲存於distance，並將起始頂點標記為selectⅡ 選出最小距離的頂點，將其最小距離儲存於distance並標記為selectⅢ 將distance中其他尚未被選擇頂點的距離與被選出頂點其最小距離+被選出頂點到該點的原始距離進行比較，若較小則更新 頂點0到其他頂點的最短距離 任兩頂點間之最短距離【有向網路】任兩頂點間之最短距離將N個頂點依序編號(0, 1, …, N-1)Ⅰ 定義A-1為任兩頂點間最原始的距離矩陣Ⅱ 定義k(0 &lt;= k &lt;= N-1) 限制頂點i到頂點j的路徑不得通過大於編號k的頂點Ⅲ k-1距離矩陣中的距離與頂點i通過頂點k到頂點j的距離(i-j-k)選擇較小者當k=N-1，即可得任兩頂點間之最短距離矩陣 AOV (Activity on Vertex) Network 應用於工作規劃 一頂點(Vertex) = 一項工作(Activity) 拓樸排序 (Topology Sort)AOV-拓樸排序依序列出AOV Network中的所有頂點，並維持先後順序。Ⅰ 任選一個沒有predecessor(整行為0)的頂點Ⅱ 將該頂點與其相關的邊刪除(刪除該頂點的欄與列)Ⅲ 重複執行ⅠⅡ，直到所有頂點都已選擇 在程式中透過selected_ver矩陣標記被選擇的頂點，以刪除該頂點與其相關的邊，避免被重複選擇。","link":"/ds-graph/"},{"title":"軟體工程師有三種，你是哪一種?","text":"Why 了解軟體工程師的種類與職涯發展方向。 成為一名優秀的軟體工程師所需技能。 軟體工程師可依照思維區分為三種類型。 What在文章剖析IT人員工作種類中，可以大致瞭解IT領域人員的各個職稱與工作內容。再依照自身的興趣，選定想走的方向，並到人力銀行使用關鍵字進行搜索，進而了解並整理出各個職位的必備技能，以供未來進修學習的方向。以下為我有興趣的職位: 研究開發人員(RD)軟體工程師 前端 後端 DevOps 系統分析師 程式撰寫前進行規劃與設計。 使用者與開發團隊間的溝通橋樑。 須具備多年程式設計經驗。 軟體工程師的三種類型可依照思維區分為: 1. Coder對於被交付的任務，只求盡快且輕鬆的完成工作。也就是老闆說什麼，就做什麼。不質疑功能的好壞，不提出更好的想法以優化產品。寫程式時看重輸入、輸出與結果。產品只是所有功能的結合，很可能不符合使用者需求。企業若想開發出好產品，必須要有很厲害的PM與PD。 2. HackerKnow and do 和 Don’t know and do 這兩類型的人都可以稱為 Hacker。因此 Hacker 也被稱為 Doer。Hacker一詞，在字典上有兩個解釋，分別為: 寫程式和解決問題的專家。 (Know and do) 沒有技能或天賦而投入於活動中的人。 (Don’t know and do) 為什麼做? 對Hacker而言很重要，他們致力於打造好用且創新的產品。因此提出更好的想法以優化產品，思考產品是否有用?是否能符合需求? 3. Architect寫程式時看重架構、優化、成本、格局。持續的學習、思考、質疑、創造。用Geek來稱呼這些人也不為過!他們擁有兩大特徵: 喜歡有秩序，可以重複使用且永久保存的code 樂於分享 他們致力於開創新系統、新套件、新框架，將複雜重複的流程打包以簡化流程，並無私的分享給世界，對於IT領域有很大的貢獻。例如: Linux, Open source 。 Reflection期許自己在軟體工程師的職涯中，永遠當一個Hacker，並朝著Architect之路邁進。雖然寫code的功力還遠遠不足，但我可以一直是個分享者Giver，持續的學習並分享。 參考資料 如果妳也開始學寫Code－依個性分類，會是哪種程式設計師？ 剖析IT人員工作種類 SA,SD與SE 程式員求生指南：關於寫程式的二三事","link":"/engineer-3types/"},{"title":"Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hexo/"},{"title":"2020新加坡商鈦坦科技台北實習生面試","text":"應徵職位: 軟體工程師 (台北學期實習生) 面試之前的小功課 完成鈦坦電子履歷 看敏捷思維的影片，回答三個問題 邏輯測驗 DISC人格測驗 面試流程 程式筆試(30min) 暖場自我介紹活動 跑關面試 製作海報發表 桌遊 回顧(Retro) 程式筆試 印出三角形1234567 # ## #-##--# #-# ## # 判斷n為2的幾次方 n = 4; return 2 n = 3; return -1 不確定有沒有記錯 n = 4; ary = [2, 5, 1, 4] if n 在 ary 中: True else: False [1, 2, 3, 4, 5, 6, 7]找出第三大的數字 SQL 暖場自我介紹活動 在一張A4紙上，寫上希望別人怎麼稱呼你，三句有關於自己的話(可以多寫)，並畫出一個能夠代表自己的圖案。 利用這張紙，跟身旁的夥伴介紹自己，並請對方簽名，至少蒐集到三個名子。 活動結束後，主持人會問大家對誰印象最深刻。 跑關面試(5關)問題可分為這五大類 未來規劃 跳脫框架 你跟你的朋友分一塊Pizza，請問你會怎麼切讓自己吃到最多? 在大學有沒有做過什麼跳脫框架的事? 衝突失敗 描述衝突與失敗的經驗，並將重點放在你怎麼面對與解決。 程式邏輯 根據程式筆試所寫的答案，討論程式邏輯，演算法與時間複雜度。 針對你的履歷自傳提問 我在面試前準備的面試題目: 自我介紹在自我介紹中，提到我擅長什麼?我的優點是什麼?團隊合作的經驗，為什麼喜歡團隊合作? 想在這裡學到什麼，為什麼想來鈦坦? 失敗的經驗或挫折? 你覺得你有什麼樣的缺點? 為什麼要錄取你? 請問有沒有什麼問題想問的呢? 除了跳脫框架的問題讓我有些意外，其他的題目都可以透過我在面試前準備的這些題目，加以延伸進行回答。建議熟讀自己所寫的履歷自傳，並了解敏捷開發與Scrum。回答時間有限，當面試官問誰要先回答時?盡量爭取當第一個先說話的，以免自己還沒講到重點時，就要換關了。如果是自己沒有預料到的問題，盡量也要跟能為自己加分的經驗結合，不要亂回答。 製作海報發表 題目: 你所認為的敏捷? 方式: 拿一張海報紙，便利貼，彩色筆進行分組討論 分組討論後進行報告 我們這組寫下敏捷思維的核心概念，並舉出自己使用敏捷思維的例子。另外一組將敏捷寫在中間，並舉了三大特點下去延伸，呈現的方式類似心智圖，是很有組織的表示方式，可以學習。 桌遊 角色: 建築師: 只能比手畫腳 監工: 只能動口 工人: 戴上眼罩，動手組合積木 旁觀者: 什麼都不能做，只能用眼睛看 建築師抽取卡片，比出要組合積木的樣子與方向，給監工看。監工依照建築師的比劃，用說的方式指揮工人，應該要拿取哪一塊積木，並引導正確的角度，將積木放在正確的位子，以組合出卡片上所要求的樣子。 回顧(Retro) 將今天面試印象最深刻的事或任何想分享的事物寫在便利貼上，幾分鐘後進行口頭分享。 有沒有想要感謝的夥伴，覺得哪一位夥伴最不錯，為什麼? 寫回饋表單。","link":"/interview-Taitan/"},{"title":"物件導向的三大特性和抽象化","text":"三大特性1. 封裝 (Encapsulation)將attribute(variable)與method打包成一個class，以隱藏實作細節，提高資料完整性。其他的class只能透過method(setter/getter)修改/取得variable的值。 private variable public method 2. 繼承 (Inheritance) 父類別(superclass) 子類別(subclass) subclass inherit superclass 將多個相同性質的子類別，擷取出共有的特徵，並將這些共有特徵定義成一個父類別，讓子類別可以繼承。避免subclass重複定義相同的attribute與method。 12345678910111213141516public class Animal &#123; String name; int age; Animal (String name, int age) &#123; this.name = name; this.age = age; &#125; public void eat (String food) &#123; System.out.println(\"I want to eat \" + food); &#125;&#125; public class Dog extends Animal &#123; Dog (String name, int age) &#123; super(name, age); &#125;&#125; 覆寫 (overriding) 方法名稱，回傳型態，參數必須相同。 subclass的方法，覆寫superclass的方法。有兩個class。 subclass可以針對其特定需求覆寫superclass的方法，讓設計更為彈性。 Dog.eat override Animal.eat12345678910public class Animal &#123; public void eat () &#123; System.out.println(\"I am not hungry!\"); &#125;&#125; public class Dog extends Animal &#123; public void eat () &#123; System.out.println(\"Bones!\"); &#125;&#125; 過載 (overloading)在同一個class裡，定義了相同名稱但是結構不同的方法。例如: 回傳型態不同，參數不同。12345678public class Animal &#123; public void eat () &#123; System.out.println(\"I am not hungry!\"); &#125; public void eat (String food) &#123; System.out.println(\"I want to eat \" + food); &#125;&#125; 3. 多型 (Polymorphism)同一個方法，有不同的行為。 override interface 123456789101112131415Interface Animal &#123; public void eat(); public void move(); public void sound();&#125;class Dog implements Animal &#123; public void eat() &#123; System.out.println(\"Bones!\"); &#125;&#125;class Cat implements Animal &#123; public void eat() &#123; System.out.println(\"Fish!\"); &#125;&#125; Abstraction (抽象化)隱藏實作細節，只提供可用功能給使用者。 Abstract Class 有abstract method 的 class 即為 Abstract class。也可以包含有body實作的concrete method。 不能夠create(new)，必須被子類別繼承後才能透過子類別create。 abstract method: 沒有body的method。必須透過子類別加以實作行為。 123456abstract class Animal &#123; abstract public void sound(); // abstract method public void eat () &#123; // concrete method System.out.println(\"I am not hungry!\"); &#125;&#125; Interface 集結相關的abstract method。 只有abstract method。12345Interface Animal &#123; public void eat(); public void move(); public void sound();&#125;","link":"/oo-basic/"},{"title":"Design pattern - Factory method","text":"Factory method Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 一間工廠(creator)只專門生產一種產品(product)。 Use when a class can’t anticipate the class of objects it must create. a class wants its subclasses to specify the objects it creates. classes delegate responsibility to one of several helper subclasses, and you wantto localize the knowledge of which helper subclass is the delegate. 優點: 得以讓被create的product在run time的時候才決定 得以明確知道哪一個Creator create 哪一個Product 得以在superclass建立hooks，為subclass提供default method Connects parallel class hierarchies，creator delegate some of its responsibility to its product.例如:長條圖與折線圖都會用到getData()，但繪製的方式不同。長條圖以棒狀呈現，折線圖以線呈現，這時候creator就可以委託product做變化。 在observer中提到spreadsheet create chart可以使用factory method。 spreadsheet不需要綁定特定的chart123456789101112131415161718192021222324class spreadSheet &#123; ArrayList&lt;chart&gt; charts = new ArrayList&lt;Chart&gt;(); private chartFactory factory; public void attach() &#123; factory = configure(); // 要使用哪間工廠 Chart chart = factory.createChart(type); charts.add(chart); &#125;&#125;// Creatorinterface chartFactory &#123; public Chart createChart();&#125;class barChartFactory implements spreadSheet &#123; public Chart createChart() &#123; return new barChart(); &#125;&#125;class lineChartFactory implements spreadSheet &#123; public Chart createChart() &#123; return new lineChart(); &#125;&#125; 缺點: 有很多的creator，只是為了create product client必須判斷要使用哪一個creator Factory method與Abstract factory很像，但Abstract factory強調組合的關係。通常在使用Abstract factory的同時，會使用Factory method。 Simple factory只有一間工廠，客戶指定要什麼就生產什麼。1234567891011121314151617181920212223abstract class spreadSheet &#123; ArrayList&lt;chart&gt; charts = new ArrayList&lt;Chart&gt;(); public abstract Chart createChart(String type); public void attach(String type) &#123; Chart chart = chartFactory.createChart(type); charts.add(chart); &#125;&#125;class chartFactory &#123; public static Chart createChart(String type) &#123; switch(type) &#123; case \"bar\": return new barChart(); case \"line\": return new lineChart(); default: return new barChart(); &#125; &#125;&#125; Simple factory vs Factory methodUse SimpleFactory when the types of Objects are not fixed.Use Factory method when the types of Objects are fixed.當決定好class的數量，使用Factory method。","link":"/oo-dp-factory/"},{"title":"Design pattern - Visitor","text":"Visitor Represent an operation to be performed on an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. Use when Object structure固定不變，但方法需要不斷擴充時當Object structure中的concrete classes有許多不同且不相關的方法，使用Visitor pattern，讓concrete classes在需要擴充新方法時，不需要進行改變。 不同的concrete class執行方法不同 想像有一個公園，裡面有樹，草皮，長椅，步道。有工人與民眾這兩個角色可以到這個公園裡面從事活動。工人修剪樹木、整理草皮、維護長椅、清理步道；民眾坐在樹下、躺在草皮上、坐在長椅上、在步道上散步。 此處的 Object structure 為 Composite，也可以是Collection(list / set) 使用Visitor pattern前:parkComponent (Object structure)中有維護與計算人數的方法。每一個Concrete class維護的方法與計算人數的依據皆不同。例如: Tree的維護方法為Worker修剪，並依據是否有樹蔭來計算人數；Bench的維護方法為Worker修理，並依據是否壞掉來計算人數。為了改善concrete classes中有許多不同且不相關方法的問題，使用visitor pattern將方法整合到visitor中，以提高cohesion。12345678910111213141516171819202122abstract class parkComponent &#123; abstract public void maintain(); abstract public void countVisited();&#125;class Tree extends parkComponent &#123; public void maintain() &#123; // worker cut the tree &#125; public void countVisited() &#123; // if have shadowing // citizen++ &#125;&#125;class Bench extends parkComponent &#123; public void maintain() &#123; // worker repair the bench &#125; public void countVisited() &#123; // if bench is not broken // citizen++ &#125;&#125; 使用Visitor pattern後:不同的Visitor根據不同的concrete classes執行不同的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950interface Visitor &#123; public void visitTree(Tree tree); public void visitGress(Gress gress); public void visitBench(Bench bench); public void visitTrail(Trail trail);&#125;class Worker implements Visitor &#123; public void visitTree(Tree tree) &#123; // trim tree.overgrowth = false; &#125; public void visitGress(Gress gress) &#123; // mow gress.overgrowth = false; &#125; public void visitBench(Bench bench) &#123; // repair bench.broken = false; &#125; public void visitTrail(Trail trail) &#123; // clean trail.messy = false; &#125;&#125;class Citizen implements Visitor &#123; public void visitTree(Tree tree) &#123; // sit under the tree visited++; &#125; public void visitGress(Gress gress) &#123; if (!tree.overgrowth) &#123; // lay on the gress visited++; &#125; else &#123; // call worker to mow &#125; &#125; public void visitBench(Bench bench) &#123; if (!bench.broken) &#123; // sit on the bench visited++; &#125; else &#123; // call worker to repair &#125; &#125; public void visitTrail(Trail trail) &#123; // walk on the trail visited++; &#125;&#125; 12345678910111213141516171819202122232425262728abstract class ParkComponent &#123; protected int visited; abstract public void accept(Visitor v);&#125;class Tree extends ParkComponent &#123; boolean overgrowth; public void accept(Visitor v) &#123; v.visitTree(this); &#125;&#125;class Gress extends ParkComponent &#123; boolean overgrowth; public void accept(Visitor v) &#123; v.visitGress(this); &#125;&#125;class Bench extends ParkComponent &#123; boolean broken; public void accept(Visitor v) &#123; v.visitBench(this); &#125;&#125;class Trail extends ParkComponent &#123; boolean messy; public void accept(Visitor v) &#123; v.visitTrail(this); &#125;&#125; Pros and ConsPros: 遵守Open-Closed principle。可以在不改變Object structure的情況下，輕鬆的擴充新方法 Visiting across class hierarchies. 可以visit 沒有統一抽象介面(abstract class / interface)的elements；也就是說，可以在visitor當中加入任何type的elementsInterator也可以visit Object structure，但是必須要有統一的抽象介面 Accumulating state. 當visit Object structure中的每一個element時，可以積累state例如例子當中visited變數的累計，當Citizen visit Park中的每一個element時visited+1沒有使用Visitor時，會以globle variable或傳遞參數的方式來改變這個state Cons: Concrete element新增困難。每新增一個新的concrete element，abstract visitor和相關的concrete visitor必須新增方法，供此concrete element使用所以只應該在element hierarchy固定不變，但新方法會需要不斷擴充的情況下使用Visitor pattern 破壞封裝。concrete element的attribute可以被visitor修改","link":"/oo-dp-visitor/"},{"title":"Design pattern - Observer","text":"Observer Define a one-to-many dependency between objects so that when one object changes state, all its depends are notified and updated automatically. maintain consistency without tightly coupled to increase reusablity.當兩個object間的資訊需要同步更新的時候，透過observer pattern維護資訊的一致性，並降低之間的coupling。 以Youtube為例使用Youtube時，使用者對喜歡的youtuber按下訂閱，當該Youtuber發布最新的影片時，使用者就可以收到該Youtuber最新的影片。 When subject changed, notify all observers to update.But… Who triggers the update()?狀態更新可以透過兩種方式，各有優缺點 Client call Notifyclient forgot to call Observer call Notifyinefficient 1. Client call Notify想像使用Youtube時，當使用者對喜歡的youtuber按下訂閱，則觸發addSubscriber將此使用者新增到Youtuber的subscribers List中。當youtuber上傳最新影片時，觸發uploadVideo，通知所有訂閱者(observers)該youtuber(subject)最新的影片。123456789101112131415161718192021222324252627282930// Subjectclass Youtuber &#123; private ArrayList&lt;Subscriber&gt; subscribers = new ArrayList&lt;Subscriber&gt; public void attach(Subscriber sub) &#123; subscribers.add(sub); &#125; public void detach(Subscriber sub) &#123; subscribers.remove(sub); &#125; public void notify() &#123; for (sub : subscribers) &#123; sub.update(this); &#125; &#125;&#125;class concreteYoutuber extends Youtuber &#123; private Video video; public void setVideo(Video v) &#123; this.video = v; this.notify(); &#125; public void getVideo() &#123; return video; &#125;&#125; 12345678910// ObserverInterface Subscriber &#123; public void update(Youtuber ytb);&#125;class concreteSubscriber implements Subscriber &#123; private Video video; public void update(Youtuber ytb) &#123; this.video = ytb.getVideo(); &#125;&#125; 123456789101112// Clientclass Controller &#123; Youtuber rdEnglish = new concreteYoutuber(); // when user click the subscribe button public void addSubscriber(Subscriber subscriber) &#123; rdEnglish.attach(subscriber); &#125; // when youtuber upload video then notify all subscribers public void uploadVideo() &#123; rdEnglish.setVideo(video); &#125;&#125; 2. Observer call Notify想像在Excel中，為一張試算表的資料繪製一張長條圖與折線圖。按下新增圖表，觸發attach方法，以建立圖表。(可以透過Factory method建立不同的圖表)當改變試算表中的資料時，觸發setData，並呼叫Notify以同步更新其他圖表的資料。當改變圖表中的資料時，觸法setChartData，呼叫sheet的setData方法更新試算表的資料，並呼叫Notify同步更新其他圖表的資料。1234567891011121314151617181920212223242526272829303132// Subjectclass spreadSheet &#123; ArrayList&lt;chart&gt; charts = new ArrayList&lt;Chart&gt;(); public void attach() &#123; Chart chart = new Chart(); charts.add(chart); &#125; public void detach(Chart chart) &#123; charts.remove(chart); &#125; public void Notify()&#123; for(c : charts) &#123; c.update(this); &#125; &#125;&#125;class concreteSpreadSheet extends spreadSheet &#123; Data data = null; public setData(Data newData) &#123; this.data = newData; this.Notify(); &#125; public Data getData() &#123; return data; &#125;&#125; 123456789101112131415161718192021222324// Observerclass Chart &#123; spreadSheet sheet; Data data; public void update(spreadSheet sheet) &#123; this.sheet = sheet; this.data = sheet.getData(); &#125; public void setChartData (Data newData) &#123; sheet.setData(newData); &#125; public void delete() &#123; sheet.detach(this); &#125;&#125;class barChart extends Chart &#123; ...&#125;class lineChart extends Chart &#123; ...&#125; Pros and ConsPros: Coupling between subjects and observers is abstract and minimal. Subject and Observer can vary independently. Subject不需要知道要更新哪些Observer。兩者可獨立的變化，提高複用性。 Cons: Unexpected updates. Observer不需要知道其他的Observer。雖然降低coupling，但可能造成資訊更新難以追蹤，資訊更新錯誤的問題。","link":"/oo-dp-observer/"},{"title":"物件導向的五大原則","text":"SOLID 原則1. SRP (Single Responsibility Principle) 一個class只對一種role(actor)負責。 以電子支付為例，使用者可以收付款項。建立一個User class，包含收錢與付錢兩個方法。12345678class User &#123; public void receive()&#123; System.out.println(\"收錢\"); &#125; public void pay()&#123; System.out.println(\"付錢\"); &#125; &#125; 當userA要付錢給userB，我們可能會這麼寫123456public static void main (string[] args) &#123; User userA = new User(); User userB = new User(); userA.pay(); userB.receive();&#125; 在作者Finn-SRP這篇文章中提到: 如果兩個方法的連動永遠都是同時變化，那就不必分離，否則可能造成不必要的複雜性。 提醒我們需避免過度優化，將功能切割的過於細小，而使程式過於複雜。 上面的程式似乎符合同時的連動與變化，還算容易理解與維護，但功能增加或需要修改時，可能就不太理想了。我們試著增加一些功能: 收款方，顯示QRcode，付款方掃描並驗證其QRcode後，輸入支付金額。收款方確認支付金額無誤後，才完成交易。並且雙方在交易完成後都能有現金5%的回饋。123456789101112131415161718192021class User &#123; public void receive()&#123; this.showQRcode(); this.verifyInputMoney(); this.cashBonus(); &#125; public void showQRcode()&#123;...&#125;; public void verifyInputMoney()&#123;...&#125; public void pay()&#123; this.openCamera(); this.verifyQRcode(); int money = scanner.NextInt(); this.cashBonus(); &#125; public void openCamera()&#123;...&#125;; public void verifyQRcode()&#123;...&#125;; public void cashBonus() &#123; balance = balance + money*5%; &#125;&#125; 若今天將政策改成付款方享有10%的現金回饋，而收款方現金回饋5%保持不變，問題就浮現了。 User class中的方法，同時對兩個actor負責。一個是付款方(payer)，另一個是收款方(payee)。因此建立兩個新的class，並將method切割出來，以實現RSP原則(一個class只對一個actor負責)。也能避免日後需求改變，修改方法(cashBonus)時，更動到其他角色應該有的正確行為。RSP原則，提高class的cohesion，使其易於維護與修改。 12345678910111213141516171819202122232425class Payee&#123; // 收款方 public void receive()&#123; this.showQRcode(); this.verifyInputMoney(); System.out.println(\"收錢\"); &#125; public void showQRcode()&#123;...&#125;; public void verifyInputMoney()&#123;...&#125; public void cashBonus() &#123; balance = balance + money*5%; &#125;&#125;class Payer&#123; // 付款方 public void pay()&#123; this.openCamera(); this.verifyQRcode(); int money = scanner.NextInt(); System.out.println(\"付錢\"); &#125; public void openCamera()&#123;...&#125;; public void verifyQRcode()&#123;...&#125;; public void cashBonus() &#123; balance = balance + money*10%; &#125;&#125; 2. OCP (Open-Closed Principle)在設計已經完整的前提下，修改程式的兩個主要原因為: 增加新功能 修正問題(bugs) 若修改程式是為了增加新功能，就必須符合OCP原則。 Open for extension 開放擴充 Closed for modification 避免修改 達成OCP的方式: Abstract class Interface Decorator Strategy DIP 3. LSP (Liskov Substitution Priniple) Subtypes must be substitutable for their base types. 所有的subclass必須能夠在不破壞/不修改程式的情況下，使用parent class中的所有方法。 在實作OCP的同時，必須符合LSP。以下為違反LSP的例子:以哺乳類為例，除少數哺乳類，例如:鴨嘴獸(platypus)是卵生，其餘皆為胎生。123456class Mammal &#123; public void giveBirth(); // 直接生下胎兒&#125;class Platypus extends Mammal &#123; public void layegg(); // 產卵&#125; class Platypus 無法使用class Mammal中的giveBirth method ，違反LSP原則。 extends 為 IS-A 的關係Platypus cannot giveBirth. Thus, Platypus is not a Mammal, Platypus cannot extend Mammal. 透過Design by Contract來避免違反LSP: preconditions postconditions class invariants Subclasses need to follow these rules: Don’t implement any stricter validation rules on input parameters than implemented by the parent class.父類別的條件要比子類別嚴格 Apply at the least the same rules to all output parameters as applied by the parent class. 4. ISP (Interface Segregation Principle) Clients should not be forced to depend upon interfaces that they do not use. 以遙控器為例:電視遙控器可以開，關，預錄節目。冷氣遙控器可以開，關，設定溫度。可以發現電視遙控器並不需要設定溫度的功能，冷氣遙控器並不需要預錄節目的功能。123456interface RemoteControl &#123; public void on(); public void off(); public void set(); public void record();&#125; 為了預防 Bloated Interface，透過ISP原則，將Interface進行切割。我們建立兩個新的Interface，TVRemote與AirConditionerRemote，將電視與冷氣個別會用到的功能切割出去。interface RemoteControl則保留最基本的遙控器開關功能。123456789101112interface TVRemote &#123; public void setChannel(); public void record();&#125;interface AirConditionerRemote &#123; public void setTemperature(); public void setTime();&#125;interface RemoteControl &#123; public void on(); public void off();&#125; ISP與SRP相似，主張Class或Interface不應該包含多種用不到的或不相關的責任。避免需求改變時，因程式修改所產生的負面影響。因此將Class或Interface切割，雖然Class或Interface的數量增加，但cohesion提高。兩者之間的差異: ISP避免Interface包含了client用不到的method SRP避免一個Class負責不同的角色 5. DIP (Dependency Inversion Principle) High-level modules should not depend on low-level modules. Both should depend on abstractions.Abstractions should not depend on details. Details should depend on abstractions. 切割兩個Class之間的依賴關係，建立一個新的抽象介面(Abstraction)，讓Class更容易擴充(OCP)，同時也必須遵守(LSP)。只要持續且正確的應用OCP與LSP，將會符合DIP。splits the dependency between the high-level and low-level modules by introducing an abstraction between them. So in the end, there are two dependencies: the high-level module depends on the abstraction, and the low-level depends on the same abstraction. 以Airplane為例，飛機可以在跑道上跑(run)，也可以飛到空中(fly)。Jet依賴於Airplane的run和fly功能，並且可以射擊(shoot)與防禦(defend)。123456789101112131415class Airplane &#123; public void run () &#123;...&#125; public void fly () &#123;...&#125;&#125;class Jet &#123; private Airplane airplane public void run () &#123; airplane.run(); &#125; public void fly () &#123; airplane.fly(); &#125; public void shoot () &#123;...&#125; public void defend () &#123;...&#125;&#125; 為了降低coupling(減少class之間的依賴關係)，並讓功能容易擴充避免修改(OCP)，建立Interface AirplaneAction，讓Airplane和Jet可以實作run和fly。由於Airplane並不能shoot和defend，因此新增一個軍備的Interface Arms，讓Jet實作shoot和defend，以遵守LSP。 參考資料SRPOCPLSPISPDIP","link":"/oo-principle/"},{"title":"遞迴與迴圈","text":"遞迴 Recursion以求N的階乘為例fac(1) = 1fac(N) = N * fac(N-1) 內涵式遞迴 Embedded recursion 最後一個函式fac(1)呼叫完成後，一層層由內而外回傳數值並計算。 階層式架構 123456public int fac(int n) &#123; if (n == 1) // 設定終止條件 return 1; else return n * fac(n-1); // 控制變數 n，使其接近終止值&#125; fac(3)return 3 * fac(3-1) // n=3return 3 * 2 * fac(2-1) // n=2return 3 * 2 * 1 * fac(1) // n=1 尾端式遞迴 Tail recursion 增加一個參數(ans)，紀錄累乘值。 平的架構 123456public int fac(int n, int ans) &#123; if (n == 0) //設定終止條件 return ans; else return fac(n-1, ans*n); // 控制變數 n，使其接近終止值&#125; fac(3, 1)return fac(2, 1*3)return fac(1, 3*2)return fac(0, 6*1) 可以將尾端式遞迴轉換成While迴圈 迴圈 Loop 將尾端式遞迴的終止條件，以not的形式當作while的進行條件。 將參數的變動放在迴圈中，必須先累乘，才將n-1。 12345678public int fac(int n) &#123; int ans = 1; while (n != 0) &#123; // 設定進行條件 ans = ans * n; n--; // 控制變數 n，使迴圈得以停止 &#125; return ans;&#125;","link":"/recursion/"},{"title":"weatherMap","text":"A Taiwan weather map create by Vue.js. demo codepen: https://codepen.io/becomegood0308/pen/GbyNVM svg name and get id/data-name data regular expressions json data array Vue.js / jQuery vobj = vm vm.filter = &lt;p id=&quot;&quot;&gt; 參考資料https://www.youtube.com/watch?v=eHrGB5EHtF4","link":"/weatherMap/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"pointer","slug":"pointer","link":"/tags/pointer/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"reflection","slug":"reflection","link":"/tags/reflection/"},{"name":"internship","slug":"internship","link":"/tags/internship/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"OOSE","slug":"OOSE","link":"/tags/OOSE/"},{"name":"Design pattern","slug":"Design-pattern","link":"/tags/Design-pattern/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"json","slug":"json","link":"/tags/json/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Algorithm","slug":"Notes/Algorithm","link":"/categories/Notes/Algorithm/"},{"name":"Front-end","slug":"Notes/Front-end","link":"/categories/Notes/Front-end/"},{"name":"Data Structure","slug":"Notes/Data-Structure","link":"/categories/Notes/Data-Structure/"},{"name":"Reflection","slug":"Reflection","link":"/categories/Reflection/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"OOSE","slug":"Notes/OOSE","link":"/categories/Notes/OOSE/"}]}