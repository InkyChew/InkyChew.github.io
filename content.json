{"pages":[{"title":"About Me","text":"周郁穎 Inky 積極嘗試新事物並且挑戰自我的行動者，多元讓我看見不同可能，並擁有精彩人生。熱愛思考、創新求變，期望能為世界創造價值，成為一個有影響力的人。相信走過的每一哩路都有意義，因而認真看待每一件事，努力耕耘。 8th March, 1999 Taichung, Taiwan 雲林科技大學 資訊管理系 inky11308@gmail.com 程式技能 Vue.js, Flask, Bootstrap HTML, Pug, SCSS JavaScript, PHP, Java, Python, SQL 語言能力 TOEFL iBT 80 TOEIC 825 全民英檢 中級","link":"/about/index.html"}],"posts":[{"title":"Bubble sort","text":"Bubble sort 氣泡排序法 每一次比較兩個相鄰數值，如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置。因為已經確保最大數值的位置，因此下一次需要比較的數值會少一個。 將以上的敘述拆解: 每一次比較兩個相鄰元素思考要比較幾次?假設有五個數值，兩兩相比需比較四次。我們可以用arr.length-1表示。 兩相鄰元素比較次數 = 總元素數量-1 下一次需要比較的元素會少一個第0次比較兩個相鄰元素，( 總元素數量-0 )-1個數值第1次比較兩個相鄰元素，( 總元素數量-1 )-1個數值第2次比較兩個相鄰元素，( 總元素數量-2 )-1個數值…第i次比較兩個相鄰元素，arr.length-i-1個數值 如果前面的數值大於後面的數值就交換位置，以確保最大的數值在最後一個位置 123456789for (int i = 0; i &lt; arr.length-1; i++) &#123; // 1. for (int j = 0; j &lt; arr.length-i-1; j++) &#123; // 2. if (arr[j] &gt; arr[j+1]) &#123; // 3. int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125;&#125; Time complexity: O(n*n)上述的程式碼缺乏效率，儘管陣列中所有的元素都已經排序完成，程式依然執行n*n次。 觀察下方的圖片幫助理解我們可以發現執行第6次時就已經完成排序，但卻執行了10次 Optimized implementation如何知道所有的元素已經排序完成?當兩相鄰元素的交換不再發生時，即完成所有元素的排序 1234567891011121314151617181920for (int i = 0; i &lt; arr.length-1; i++) &#123; boolean swapped = false; for (int j = 0; j &lt; arr.length-i-1; j++) &#123; if (arr[j] &lt; arr[j+1]) &#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; // 當有交換發生時，將swapped設成true swapped = true; &#125; &#125; // 當兩相鄰元素的交換不再發生時 // 所有元素排序完成 if (swapped == false) break;&#125; Time complexityWorst case: O(n*n)所需執行時間的最壞情況，發生在陣列當中的元素以反向排序時Best case: O(n)所需執行時間的最佳情況，發生在陣列當中的元素已經排序好時 參考資料geeksforgeeks-Bubble sort[演算法] 氣泡排序法 Bubble Sort","link":"/2020/12/24/algo-sort-bubble/"},{"title":"algo","text":"Algorithm演算法系列文章時間複雜度（Time Complexity）&amp; big-O空間複雜度 資料結構的各項操作 排序（Sorting）： Bubble sort Insertion sort Quick sort Merge sort 搜尋（Searching） Depth-first-search Breadth-first-search Binary search 遞迴（recursive）分治法（divide and conquer）迭代（iteration）","link":"/2020/12/24/algo/"},{"title":"TodoList","text":"A To-do-list create by Vue.js. https://github.com/InkyChew/Vue.js_todolist body中引入vue.js&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; Directivev-model 資料雙向綁定v-on methodv-ifv-forv-focus 自訂directive，防止多個 li 因 v-model 綁定同時修改 1234567directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125;, v-bind:class=&quot;{&#39;completed&#39; : todo.completed}&quot;use completed class ， when todo.completed == true :class 無法使用data綁定class:style 可使用data綁定class 配置方式 123456var app = new Vue(&#123; el:&apos;&apos;, //綁定最外層要素 data: &#123;&#125;, //綁定 v-model 資料 computed:&#123;&#125;, //即時更新的運算資料 methods: &#123;&#125;&#125;) 參考資料https://peterhpchen.github.io/VuejsQuest/basic/06_Directives.html#%E4%BB%8B%E7%B4%B9https://quip.com/M2eCAQo6bXh8https://vuejs.org/v2/guide/installation.html","link":"/2019/06/29/TodoList/"},{"title":"Time Complexity","text":"在寫程式時，同一個問題，可以有多個不同的解法，因此我們需要衡量不同方法的時間與空間複雜度，以找到最佳的解法。在現代，儲存空間已經不是太大的問題，因此我們關注程式的效率，也就是演算法的時間複雜度(Time Complexity)。 Time Complexity 時間複雜度隨著輸入資料量的增加，執行時間的變化使用Asymptotic Notation表示時間複雜度。 Asymptotic Notation 漸近符號 Big-O ( Ο ): 以Ο()表示演算法所需執行時間的最壞情況 Omega ( Ω ): 以Ω()表示演算法所需執行時間的最佳情況 Theta ( θ ): 以θ()表示演算法所需執行時間的範圍，包含了最壞與最佳情況 時間複雜度所需執行時間，由短到長:1(常數) &lt; log n &lt; n &lt; n log n &lt; n^2 &lt; 2^n &lt; n! 以Big-O表示時間複雜度的四種常見類型1. Constant Run Time (O(1))不管資料量大小，執行時間都一樣。 12345678var arr = [1,2,3,4,5]var arr2 = [1,2,3,4,5,6,7,8,9,10]function constant(arr) &#123; console.log(arr[0]);&#125;// 不管傳入arr或arr2，執行次數皆為一次。 2. Logarithmic Run Time (O(log n))隨著資料量增加，執行時間趨緩。 123456789while(n &gt; 0) &#123; n = n / 2;&#125;/** var n = 10 * n -&gt; 10, 5, 2, 1, 0 * var n = 15 * n -&gt; 7, 3, 1, 0 **/ 3. Linear Run Time (O(n))隨著資料量增加，執行時間成線性等比例成長。12345for(int i = 0; i &lt; n; i++) &#123; ...&#125;// 執行次數為n次 4. Exponential Run Time (O(n^2))隨著資料量增加，執行時間成指數成長。 1234567for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; ... &#125;&#125;// 執行次數為n*n次 參考資料[演算法] Big O and Time Complexity[演算法] Big O Notation &amp; Time Complexity","link":"/2020/12/23/algo-timeComplexity/"},{"title":"軟體工程師有三種，你是哪一種?","text":"Why 了解軟體工程師的種類與職涯發展方向。 成為一名優秀的軟體工程師所需技能。 軟體工程師可依照思維區分為三種類型。 What在文章剖析IT人員工作種類中，可以大致瞭解IT領域人員的各個職稱與工作內容。再依照自身的興趣，選定想走的方向，並到人力銀行使用關鍵字進行搜索，進而了解並整理出各個職位的必備技能，以供未來進修學習的方向。以下為我有興趣的職位: 研究開發人員(RD)軟體工程師 前端 後端 DevOps 系統分析師 程式撰寫前進行規劃與設計。 使用者與開發團隊間的溝通橋樑。 須具備多年程式設計經驗。 軟體工程師的三種類型可依照思維區分為: 1. Coder對於被交付的任務，只求盡快且輕鬆的完成工作。也就是老闆說什麼，就做什麼。不質疑功能的好壞，不提出更好的想法以優化產品。寫程式時看重輸入、輸出與結果。產品只是所有功能的結合，很可能不符合使用者需求。企業若想開發出好產品，必須要有很厲害的PM與PD。 2. HackerKnow and do 和 Don’t know and do 這兩類型的人都可以稱為 Hacker。因此 Hacker 也被稱為 Doer。Hacker一詞，在字典上有兩個解釋，分別為: 寫程式和解決問題的專家。 (Know and do) 沒有技能或天賦而投入於活動中的人。 (Don’t know and do) 為什麼做? 對Hacker而言很重要，他們致力於打造好用且創新的產品。因此提出更好的想法以優化產品，思考產品是否有用?是否能符合需求? 3. Architect寫程式時看重架構、優化、成本、格局。持續的學習、思考、質疑、創造。用Geek來稱呼這些人也不為過!他們擁有兩大特徵: 喜歡有秩序，可以重複使用且永久保存的code 樂於分享 他們致力於開創新系統、新套件、新框架，將複雜重複的流程打包以簡化流程，並無私的分享給世界，對於IT領域有很大的貢獻。例如: Linux, Open source 。 Reflection期許自己在軟體工程師的職涯中，永遠當一個Hacker，並朝著Architect之路邁進。雖然寫code的功力還遠遠不足，但我可以一直是個分享者Giver，持續的學習並分享。 參考資料 如果妳也開始學寫Code－依個性分類，會是哪種程式設計師？ 剖析IT人員工作種類 SA,SD與SE 程式員求生指南：關於寫程式的二三事","link":"/2020/12/02/engineer-3types/"},{"title":"Hello Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/28/hello-world/"},{"title":"2020新加坡商鈦坦科技台北實習生面試","text":"應徵職位: 軟體工程師 (台北學期實習生) 面試之前的小功課 完成鈦坦電子履歷 看敏捷思維的影片，回答三個問題 邏輯測驗 DISC人格測驗 面試流程 程式筆試(30min) 暖場自我介紹活動 跑關面試 製作海報發表 桌遊 回顧(Retro) 程式筆試 印出三角形1234567 # ## #-##--# #-# ## # 判斷n為2的幾次方 n = 4; return 2 n = 3; return -1 不確定有沒有記錯 n = 4; ary = [2, 5, 1, 4] if n 在 ary 中: True else: False [1, 2, 3, 4, 5, 6, 7]找出第三大的數字 SQL 暖場自我介紹活動 在一張A4紙上，寫上希望別人怎麼稱呼你，三句有關於自己的話(可以多寫)，並畫出一個能夠代表自己的圖案。 利用這張紙，跟身旁的夥伴介紹自己，並請對方簽名，至少蒐集到三個名子。 活動結束後，主持人會問大家對誰印象最深刻。 跑關面試(5關)問題可分為這五大類 未來規劃 跳脫框架 你跟你的朋友分一塊Pizza，請問你會怎麼切讓自己吃到最多? 在大學有沒有做過什麼跳脫框架的事? 衝突失敗 描述衝突與失敗的經驗，並將重點放在你怎麼面對與解決。 程式邏輯 根據程式筆試所寫的答案，討論程式邏輯，演算法與時間複雜度。 針對你的履歷自傳提問 我在面試前準備的面試題目: 自我介紹在自我介紹中，提到我擅長什麼?我的優點是什麼?團隊合作的經驗，為什麼喜歡團隊合作? 想在這裡學到什麼，為什麼想來鈦坦? 失敗的經驗或挫折? 你覺得你有什麼樣的缺點? 為什麼要錄取你? 請問有沒有什麼問題想問的呢? 除了跳脫框架的問題讓我有些意外，其他的題目都可以透過我在面試前準備的這些題目，加以延伸進行回答。建議熟讀自己所寫的履歷自傳，並了解敏開發與Scrum。回答時間有限，當面試官問誰要先回答時?盡量爭取當第一個先說話的，以免自己還沒講到重點時，就要換關了。如果是自己沒有預料到的問題，盡量也要跟能為自己加分的經驗結合，不要亂回答。 製作海報發表 題目: 你所認為的敏捷? 方式: 拿一張海報紙，便利貼，彩色筆進行分組討論 分組討論後進行報告 我們這組寫下敏捷思維的核心概念，並舉出自己使用敏捷思維的例子。另外一組將敏捷寫在中間，並舉了三大特點下去延伸，呈現的方式類似心智圖，是很有組織的表示方式，可以學習。 桌遊 角色: 建築師: 只能比手畫腳 監工: 只能動口 工人: 戴上眼罩，動手組合積木 旁觀者: 什麼都不能做，只能用眼睛看 建築師抽取卡片，比出要組合積木的樣子與方向，給監工看。監工依照建築師的比劃，用說的方式指揮工人，應該要拿取哪一塊積木，並引導正確的角度，將積木放在正確的位子，以組合出卡片上所要求的樣子。 回顧(Retro) 將今天面試印象最深刻的事或任何想分享的事物寫在便利貼上，幾分鐘後進行口頭分享。 有沒有想要感謝的夥伴，覺得哪一位夥伴最不錯，為什麼? 寫回饋表單。","link":"/2020/11/26/interview-Taitan/"},{"title":"物件導向的三大特性和抽象化","text":"三大特性1. 封裝 (Encapsulation)將attribute(variable)與method打包成一個class，以隱藏實作細節，提高資料完整性。其他的class只能透過method(setter/getter)修改/取得variable的值。 private variable public method 2. 繼承 (Inheritance) 父類別(superclass) 子類別(subclass) subclass inherit superclass 將多個相同性質的子類別，擷取出共有的特徵，並將這些共有特徵定義成一個父類別，讓子類別可以繼承。避免subclass重複定義相同的attribute與method。 12345678910111213141516171819public class Animal &#123; String name; int age; Animal (String name, int age) &#123; this.name = name; this.age = age; &#125; public void eat (String food) &#123; System.out.println(\"I want to eat \" + food); &#125;&#125; public class Dog extends Animal &#123; Dog (String name, int age) &#123; super(name, age); &#125; public void eat () &#123; super.eat(\"Bones!\"); &#125;&#125; 覆寫 (overriding) 方法名稱，回傳型態，參數必須相同。 subclass的方法 覆寫 superclass的方法。 subclass可以針對其特定需求覆寫superclass的方法，讓設計更為彈性。 Dog.eat override Animal.eat12345678910public class Animal &#123; public void eat () &#123; System.out.println(\"I am not hungry!\"); &#125;&#125; public class Dog extends Animal &#123; public void eat () &#123; System.out.println(\"Bones!\"); &#125;&#125; 過載 (overloading)在同一個class裡，定義了相同名稱但是結構不同的方法。例如: 回傳型態不同，參數不同。12345678public class Animal &#123; public void eat () &#123; System.out.println(\"I am not hungry!\"); &#125; public void eat (String food) &#123; System.out.println(\"I want to eat \" + food); &#125;&#125; 3. 多型 (Polymorphism)同一個方法，有不同的行為。 override interface 123456789101112131415Interface Animal &#123; public void eat(); public void move(); public void sound();&#125;class Dog implements Animal &#123; public void eat() &#123; System.out.println(\"Bones!\"); &#125;&#125;class Cat implements Animal &#123; public void eat() &#123; System.out.println(\"Fish!\"); &#125;&#125; Abstraction (抽象化)隱藏實作細節，只提供可用功能給使用者。 Abstract Class 有abstract method 的 class 即為 Abstract class。也可以包含有body實作的concrete method。 不能夠create(new)，必須被子類別繼承後才能透過子類別create。 abstract method: 沒有body的method。必須透過子類別加以實作行為。 123456abstract class Animal &#123; public void sound(); // abstract method public void eat () &#123; // concrete method System.out.println(\"I am not hungry!\"); &#125;&#125; Interface 集結相關的abstract method。 只有abstract method。12345Interface Animal &#123; public void eat(); public void move(); public void sound();&#125;","link":"/2020/12/09/oo-basic/"},{"title":"Design pattern - Observer","text":"Observer Define a one-to-many dependency between objects so that when one object changes state, all its depends are notified and updated automatically. maintain consistency without tightly coupled to increase reusablity.當兩個object間的資訊需要同步更新的時候，透過observer pattern維護資訊的一致性，並降低之間的coupling。 以Youtube為例使用Youtube時，使用者對喜歡的youtuber按下訂閱，當該Youtuber發布最新的影片時，使用者就可以收到該Youtuber最新的影片。 When subject changed, notify all observers to update.But… Who triggers the update()?狀態更新可以透過兩種方式，各有優缺點 Client call Notifyclient forgot to call Observer call Notifyinefficient 1. Client call Notify想像使用Youtube時，當使用者對喜歡的youtuber按下訂閱，則觸發addSubscriber將此使用者新增到Youtuber的subscribers List中。當youtuber上傳最新影片時，觸發uploadVideo，通知所有訂閱者(observers)該youtuber(subject)最新的影片。123456789101112131415161718192021222324252627282930// Subjectclass Youtuber &#123; private ArrayList&lt;Subscriber&gt; subscribers = new ArrayList&lt;Subscriber&gt; public void attach(Subscriber sub) &#123; subscribers.add(sub); &#125; public void detach(Subscriber sub) &#123; subscribers.remove(sub); &#125; public void notify() &#123; for (sub : subscribers) &#123; sub.update(this); &#125; &#125;&#125;class concreteYoutuber extends Youtuber &#123; private Video video; public void setVideo(Video v) &#123; this.video = v; this.notify(); &#125; public void getVideo() &#123; return video; &#125;&#125; 12345678910// ObserverInterface Subscriber &#123; public void update(Youtuber ytb);&#125;class concreteSubscriber implements Subscriber &#123; private Video video; public void update(Youtuber ytb) &#123; this.video = ytb.getVideo(); &#125;&#125; 123456789101112// Clientclass Controller &#123; Youtuber rdEnglish = new concreteYoutuber(); // when user click the subscribe button public void addSubscriber(Subscriber subscriber) &#123; rdEnglish.attach(subscriber); &#125; // when youtuber upload video then notify all subscribers public void uploadVideo() &#123; rdEnglish.setVideo(video); &#125;&#125; 2. Observer call Notify想像在Excel中，為一張試算表的資料繪製一張長條圖與折線圖。按下新增圖表，觸發attach方法，以建立圖表。(可以透過Factory method建立不同的圖表)當改變試算表中的資料時，觸發setData，並呼叫Notify以同步更新其他圖表的資料。當改變圖表中的資料時，觸法setChartData，呼叫sheet的setData方法更新試算表的資料，並呼叫Notify同步更新其他圖表的資料。1234567891011121314151617181920212223242526272829303132// Subjectclass spreadSheet &#123; ArrayList&lt;chart&gt; charts = new ArrayList&lt;Chart&gt;(); public void attach() &#123; Chart chart = new Chart(); charts.add(chart); &#125; public void detach(Chart chart) &#123; charts.remove(chart); &#125; public void Notify()&#123; for(c : charts) &#123; c.update(this); &#125; &#125;&#125;class concreteSpreadSheet extends spreadSheet &#123; Data data = null; public setData(Data newData) &#123; this.data = newData; this.Notify(); &#125; public Data getData() &#123; return data; &#125;&#125; 123456789101112131415161718192021222324// Observerclass Chart &#123; spreadSheet sheet; Data data; public void update(spreadSheet sheet) &#123; this.sheet = sheet; this.data = sheet.getData(); &#125; public void setChartData (Data newData) &#123; sheet.setData(newData); &#125; public void delete() &#123; sheet.detach(this); &#125;&#125;class barChart extends Chart &#123; ...&#125;class lineChart extends Chart &#123; ...&#125; Pros and ConsPros: Coupling between subjects and observers is abstract and minimal. Subject and Observer can vary independently. Subject不需要知道要更新哪些Observer。兩者可獨立的變化，提高複用性。 Cons: Unexpected updates. Observer不需要知道其他的Observer。雖然降低coupling，但可能造成資訊更新難以追蹤，資訊更新錯誤的問題。","link":"/2020/12/17/oo-dp-observer/"},{"title":"物件導向的五大原則","text":"SOLID 原則1. SRP (Single Responsibility Principle) 一個class只對一種role(actor)負責。 以電子支付為例，使用者可以收付款項。建立一個User class，包含收錢與付錢兩個方法。12345678class User &#123; public void receive()&#123; System.out.println(\"收錢\"); &#125; public void pay()&#123; System.out.println(\"付錢\"); &#125; &#125; 當userA要付錢給userB，我們可能會這麼寫123456public static void main (string[] args) &#123; User userA = new User(); User userB = new User(); userA.pay(); userB.receive();&#125; 在作者Finn-SRP這篇文章中提到: 如果兩個方法的連動永遠都是同時變化，那就不必分離，否則可能造成不必要的複雜性。 提醒我們需避免過度優化，將功能切割的過於細小，而使程式過於複雜。 上面的程式似乎符合同時的連動與變化，還算容易理解與維護，但功能增加或需要修改時，可能就不太理想了。我們試著增加一些功能: 收款方，顯示QRcode，付款方掃描並驗證其QRcode後，輸入支付金額。收款方確認支付金額無誤後，才完成交易。並且雙方在交易完成後都能有現金5%的回饋。123456789101112131415161718192021class User &#123; public void receive()&#123; this.showQRcode(); this.verifyInputMoney(); this.cashBonus(); &#125; public void showQRcode()&#123;...&#125;; public void verifyInputMoney()&#123;...&#125; public void pay()&#123; this.openCamera(); this.verifyQRcode(); int money = scanner.NextInt(); this.cashBonus(); &#125; public void openCamera()&#123;...&#125;; public void verifyQRcode()&#123;...&#125;; public void cashBonus() &#123; balance = balance + money*5%; &#125;&#125; 若今天將政策改成付款方享有10%的現金回饋，而收款方現金回饋5%保持不變，問題就浮現了。 User class中的方法，同時對兩個actor負責。一個是付款方(payer)，另一個是收款方(payee)。因此建立兩個新的class，並將method切割出來，以實現RSP原則(一個class只對一個actor負責)。也能避免日後需求改變，修改方法(cashBonus)時，更動到其他角色應該有的正確行為。RSP原則，提高class的cohesion，使其易於維護與修改。 12345678910111213141516171819202122232425class Payee&#123; // 收款方 public void receive()&#123; this.showQRcode(); this.verifyInputMoney(); System.out.println(\"收錢\"); &#125; public void showQRcode()&#123;...&#125;; public void verifyInputMoney()&#123;...&#125; public void cashBonus() &#123; balance = balance + money*5%; &#125;&#125;class Payer&#123; // 付款方 public void pay()&#123; this.openCamera(); this.verifyQRcode(); int money = scanner.NextInt(); System.out.println(\"付錢\"); &#125; public void openCamera()&#123;...&#125;; public void verifyQRcode()&#123;...&#125;; public void cashBonus() &#123; balance = balance + money*10%; &#125;&#125; 2. OCP (Open-Closed Principle)在設計已經完整的前提下，修改程式的兩個主要原因為: 增加新功能 修正問題(bugs) 若修改程式是為了增加新功能，就必須符合OCP原則。 Open for extension 開放擴充 Closed for modification 避免修改 達成OCP的方式: Abstract class Interface Decorator Strategy DIP 3. LSP (Liskov Substitution Priniple) Subtypes must be substitutable for their base types. 所有的subclass必須能夠在不破壞/不修改程式的情況下，使用parent class中的所有方法。 在實作OCP的同時，必須符合LSP。以下為違反LSP的例子:以哺乳類為例，除少數哺乳類，例如:鴨嘴獸(platypus)是卵生，其餘皆為胎生。123456class Mammal &#123; public void giveBirth(); // 直接生下胎兒&#125;class Platypus extends Mammal &#123; public void layegg(); // 產卵&#125; class Platypus 無法使用class Mammal中的giveBirth method ，違反LSP原則。 extends 為 IS-A 的關係Platypus cannot giveBirth. Thus, Platypus is not a Mammal, Platypus cannot extend Mammal. 透過Design by Contract來避免違反LSP: preconditions postconditions class invariants Subclasses need to follow these rules: Don’t implement any stricter validation rules on input parameters than implemented by the parent class.父類別的條件要比子類別嚴格 Apply at the least the same rules to all output parameters as applied by the parent class. 4. ISP (Interface Segregation Principle) Clients should not be forced to depend upon interfaces that they do not use. 以遙控器為例:電視遙控器可以開，關，預錄節目。冷氣遙控器可以開，關，設定溫度。可以發現電視遙控器並不需要設定溫度的功能，冷氣遙控器並不需要預錄節目的功能。123456interface RemoteControl &#123; public void on(); public void off(); public void set(); public void record();&#125; 為了預防 Bloated Interface，透過ISP原則，將Interface進行切割。我們建立兩個新的Interface，TVRemote與AirConditionerRemote，將電視與冷氣個別會用到的功能切割出去。interface RemoteControl則保留最基本的遙控器開關功能。123456789101112interface TVRemote &#123; public void setChannel(); public void record();&#125;interface AirConditionerRemote &#123; public void setTemperature(); public void setTime();&#125;interface RemoteControl &#123; public void on(); public void off();&#125; ISP與SRP相似，主張Class或Interface不應該包含多種用不到的或不相關的責任。避免需求改變時，因程式修改所產生的負面影響。因此將Class或Interface切割，雖然Class或Interface的數量增加，但cohesion提高。兩者之間的差異: ISP避免Interface包含了client用不到的method SRP避免一個Class負責不同的角色 5. DIP (Dependency Inversion Principle) High-level modules should not depend on low-level modules. Both should depend on abstractions.Abstractions should not depend on details. Details should depend on abstractions. 切割兩個Class之間的依賴關係，建立一個新的抽象介面(Abstraction)，讓Class更容易擴充(OCP)，同時也必須遵守(LSP)。只要持續且正確的應用OCP與LSP，將會符合DIP。splits the dependency between the high-level and low-level modules by introducing an abstraction between them. So in the end, there are two dependencies: the high-level module depends on the abstraction, and the low-level depends on the same abstraction. 以Airplane為例，飛機可以在跑道上跑(run)，也可以飛到空中(fly)。Jet依賴於Airplane的run和fly功能，並且可以射擊(shoot)與防禦(defend)。123456789101112131415class Airplane &#123; public void run () &#123;...&#125; public void fly () &#123;...&#125;&#125;class Jet &#123; private Airplane airplane public void run () &#123; airplane.run(); &#125; public void fly () &#123; airplane.fly(); &#125; public void shoot () &#123;...&#125; public void defend () &#123;...&#125;&#125; 為了降低coupling(減少class之間的依賴關係)，並讓功能容易擴充避免修改(OCP)，建立Interface AirplaneAction，讓Airplane和Jet可以實作run和fly。由於Airplane並不能shoot和defend，因此新增一個軍備的Interface Arms，讓Jet實作shoot和defend，以遵守LSP。 參考資料SRPOCPLSPISPDIP","link":"/2020/12/10/oo-principle/"},{"title":"Design pattern - Factory method","text":"Factory method Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 一間工廠(creator)只專門生產一種產品(product)。 Use when a class can’t anticipate the class of objects it must create. a class wants its subclasses to specify the objects it creates. classes delegate responsibility to one of several helper subclasses, and you wantto localize the knowledge of which helper subclass is the delegate. 優點: 得以讓被create的product在run time的時候才決定 得以明確知道哪一個Creator create 哪一個Product 得以在superclass建立hooks，為subclass提供default method Connects parallel class hierarchies，creator delegate some of its responsibility to its product.例如:長條圖與折線圖都會用到getData()，但繪製的方式不同。長條圖以棒狀呈現，折線圖以線呈現，這時候creator就可以委託product做變化。 在observer中提到spreadsheet create chart可以使用factory method。 spreadsheet不需要綁定特定的chart123456789101112131415161718192021222324class spreadSheet &#123; ArrayList&lt;chart&gt; charts = new ArrayList&lt;Chart&gt;(); private chartFactory factory; public void attach() &#123; factory = configure(); // 要使用哪間工廠 Chart chart = factory.createChart(type); charts.add(chart); &#125;&#125;// Creatorinterface chartFactory &#123; public Chart createChart();&#125;class barChartFactory implements spreadSheet &#123; public Chart createChart() &#123; return new barChart(); &#125;&#125;class lineChartFactory implements spreadSheet &#123; public Chart createChart() &#123; return new lineChart(); &#125;&#125; 缺點: 有很多的creator，只是為了create product client必須判斷要使用哪一個creator Factory method與Abstract factory很像，但Abstract factory強調組合的關係。通常在使用Abstract factory的同時，會使用Factory method。 Simple factory只有一間工廠，客戶指定要什麼就生產什麼。1234567891011121314151617181920212223abstract class spreadSheet &#123; ArrayList&lt;chart&gt; charts = new ArrayList&lt;Chart&gt;(); public abstract Chart createChart(String type); public void attach(String type) &#123; Chart chart = chartFactory.createChart(type); charts.add(chart); &#125;&#125;class chartFactory &#123; public static Chart createChart(String type) &#123; switch(type) &#123; case \"bar\": return new barChart(); case \"line\": return new lineChart(); default: return new barChart(); &#125; &#125;&#125; Simple factory vs Factory methodUse SimpleFactory when the types of Objects are not fixed.Use Factory method when the types of Objects are fixed.當決定好class的數量，使用Factory method。","link":"/2020/12/20/oo-dp-factory/"},{"title":"遞迴與迴圈","text":"遞迴 Recursion以求N的階乘為例fac(1) = 1fac(N) = N * fac(N-1) 內涵式遞迴 Embedded recursion 最後一個函式fac(1)呼叫完成後，一層層由內而外回傳數值並計算。 階層式架構 123456public int fac(int n) &#123; if (n == 1) // 設定終止條件 return 1; else return n * fac(n-1); // 控制變數 n，使其接近終止值&#125; fac(3)return 3 * fac(3-1) // n=3return 3 * 2 * fac(2-1) // n=2return 3 * 2 * 1 * fac(1) // n=1 尾端式遞迴 Tail recursion 增加一個參數(ans)，紀錄累乘值。 平的架構 123456public int fac(int n, int ans) &#123; if (n == 0) //設定終止條件 return ans; else return fac(n-1, ans*n); // 控制變數 n，使其接近終止值&#125; fac(3, 1)return fac(2, 1*3)return fac(1, 3*2)return fac(0, 6*1) 可以將尾端式遞迴轉換成While迴圈 迴圈 Loop 將尾端式遞迴的終止條件，以not的形式當作while的進行條件。 將參數的變動放在迴圈中，必須先累乘，才將n-1。 12345678public int fac(int n) &#123; int ans = 1; while (n != 0) &#123; // 設定進行條件 ans = ans * n; n--; // 控制變數 n，使迴圈得以停止 &#125; return ans;&#125;","link":"/2020/12/11/recursion/"},{"title":"weatherMap","text":"A Taiwan weather map create by Vue.js. demo https://s.codepen.io/becomegood0308/debug/GbyNVM/NjMYzqbKOjDr codepen: https://codepen.io/becomegood0308/pen/GbyNVM svg name and get id/data-name data regular expressions json data array Vue.js / jQuery vobj = vm vm.filter = &lt;p id=&quot;&quot;&gt; 參考資料https://www.youtube.com/watch?v=eHrGB5EHtF4","link":"/2019/06/29/weatherMap/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"internship","slug":"internship","link":"/tags/internship/"},{"name":"reflection","slug":"reflection","link":"/tags/reflection/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"OOSE","slug":"OOSE","link":"/tags/OOSE/"},{"name":"Design pattern","slug":"Design-pattern","link":"/tags/Design-pattern/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"json","slug":"json","link":"/tags/json/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Algorithm","slug":"Notes/Algorithm","link":"/categories/Notes/Algorithm/"},{"name":"Front-end","slug":"Notes/Front-end","link":"/categories/Notes/Front-end/"},{"name":"Reflection","slug":"Reflection","link":"/categories/Reflection/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"OOSE","slug":"Notes/OOSE","link":"/categories/Notes/OOSE/"}]}