{"pages":[{"title":"About Me","text":"周郁穎 Inky 積極嘗試新事物並且挑戰自我的行動者，多元讓我看見不同可能，並擁有精彩人生。熱愛思考、創新求變，期望能為世界創造價值，成為一個有影響力的人。相信走過的每一哩路都有意義，因而認真看待每一件事，努力耕耘。 8th March, 1999 Taichung, Taiwan 雲林科技大學 資訊管理系 inky11308@gmail.com 程式技能 Vue.js, Flask, Bootstrap HTML, Pug, SCSS JavaScript, PHP, Java, Python, SQL 語言能力 TOEFL iBT 80 TOEIC 825 全民英檢 中級","link":"/about/index.html"}],"posts":[{"title":"TodoList","text":"A To-do-list create by Vue.js. https://github.com/InkyChew/Vue.js_todolist body中引入vue.js&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; Directivev-model 資料雙向綁定v-on methodv-ifv-forv-focus 自訂directive，防止多個 li 因 v-model 綁定同時修改 1234567directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125;, v-bind:class=&quot;{&#39;completed&#39; : todo.completed}&quot;use completed class ， when todo.completed == true :class 無法使用data綁定class:style 可使用data綁定class 配置方式 123456var app = new Vue(&#123; el:&apos;&apos;, //綁定最外層要素 data: &#123;&#125;, //綁定 v-model 資料 computed:&#123;&#125;, //即時更新的運算資料 methods: &#123;&#125;&#125;) 參考資料https://peterhpchen.github.io/VuejsQuest/basic/06_Directives.html#%E4%BB%8B%E7%B4%B9https://quip.com/M2eCAQo6bXh8https://vuejs.org/v2/guide/installation.html","link":"/2019/06/29/TodoList/"},{"title":"Hello Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/28/hello-world/"},{"title":"軟體工程師有三種，你是哪一種?","text":"Why 了解軟體工程師的種類與職涯發展方向。 成為一名優秀的軟體工程師所需技能。 軟體工程師可依照思維區分為三種類型。 What在文章剖析IT人員工作種類中，可以大致瞭解IT領域人員的各個職稱與工作內容。再依照自身的興趣，選定想走的方向，並到人力銀行使用關鍵字進行搜索，進而了解並整理出各個職位的必備技能，以供未來進修學習的方向。以下為我有興趣的職位: 研究開發人員(RD)軟體工程師 前端 後端 DevOps 系統分析師 程式撰寫前進行規劃與設計。 使用者與開發團隊間的溝通橋樑。 須具備多年程式設計經驗。 軟體工程師的三種類型可依照思維區分為: 1. Coder對於被交付的任務，只求盡快且輕鬆的完成工作。也就是老闆說什麼，就做什麼。不質疑功能的好壞，不提出更好的想法以優化產品。寫程式時看重輸入、輸出與結果。產品只是所有功能的結合，很可能不符合使用者需求。企業若想開發出好產品，必須要有很厲害的PM與PD。 2. HackerKnow and do 和 Don’t know and do 這兩類型的人都可以稱為 Hacker。因此 Hacker 也被稱為 Doer。Hacker一詞，在字典上有兩個解釋，分別為: 寫程式和解決問題的專家。 (Know and do) 沒有技能或天賦而投入於活動中的人。 (Don’t know and do) 為什麼做? 對Hacker而言很重要，他們致力於打造好用且創新的產品。因此提出更好的想法以優化產品，思考產品是否有用?是否能符合需求? 3. Architect寫程式時看重架構、優化、成本、格局。持續的學習、思考、質疑、創造。用Geek來稱呼這些人也不為過!他們擁有兩大特徵: 喜歡有秩序，可以重複使用且永久保存的code 樂於分享 他們致力於開創新系統、新套件、新框架，將複雜重複的流程打包以簡化流程，並無私的分享給世界，對於IT領域有很大的貢獻。例如: Linux, Open source 。 Reflection期許自己在軟體工程師的職涯中，永遠當一個Hacker，並朝著Architect之路邁進。雖然寫code的功力還遠遠不足，但我可以一直是個分享者Giver，持續的學習並分享。 參考資料 如果妳也開始學寫Code－依個性分類，會是哪種程式設計師？ 剖析IT人員工作種類","link":"/2020/12/02/engineer-3types/"},{"title":"2020新加坡商鈦坦科技台北實習生面試","text":"應徵職位: 軟體工程師 (台北學期實習生) 面試之前的小功課 完成鈦坦電子履歷 看敏捷思維的影片，回答三個問題 邏輯測驗 DISC人格測驗 面試流程 程式筆試(30min) 暖場自我介紹活動 跑關面試 製作海報發表 桌遊 回顧(Retro) 程式筆試 印出三角形1234567 # ## #-##--# #-# ## # 判斷n為2的幾次方 n = 4; return 2 n = 3; return -1 不確定有沒有記錯 n = 4; ary = [2, 5, 1, 4] if n 在 ary 中: True else: False [1, 2, 3, 4, 5, 6, 7]找出第三大的數字 SQL 暖場自我介紹活動 在一張A4紙上，寫上希望別人怎麼稱呼你，三句有關於自己的話(可以多寫)，並畫出一個能夠代表自己的圖案。 利用這張紙，跟身旁的夥伴介紹自己，並請對方簽名，至少蒐集到三個名子。 活動結束後，主持人會問大家對誰印象最深刻。 跑關面試(5關)問題可分為這五大類 未來規劃 跳脫框架 你跟你的朋友分一塊Pizza，請問你會怎麼切讓自己吃到最多? 在大學有沒有做過什麼跳脫框架的事? 衝突失敗 描述衝突與失敗的經驗，並將重點放在你怎麼面對與解決。 程式邏輯 根據程式筆試所寫的答案，討論程式邏輯，演算法與時間複雜度。 針對你的履歷自傳提問 我在面試前準備的面試題目: 自我介紹在自我介紹中，提到我擅長什麼?我的優點是什麼?團隊合作的經驗，為什麼喜歡團隊合作? 想在這裡學到什麼，為什麼想來鈦坦? 失敗的經驗或挫折? 你覺得你有什麼樣的缺點? 為什麼要錄取你? 請問有沒有什麼問題想問的呢? 除了跳脫框架的問題讓我有些意外，其他的題目都可以透過我在面試前準備的這些題目，加以延伸進行回答。建議熟讀自己所寫的履歷自傳，並了解敏開發與Scrum。回答時間有限，當面試官問誰要先回答時?盡量爭取當第一個先說話的，以免自己還沒講到重點時，就要換關了。如果是自己沒有預料到的問題，盡量也要跟能為自己加分的經驗結合，不要亂回答。 製作海報發表 題目: 你所認為的敏捷? 方式: 拿一張海報紙，便利貼，彩色筆進行分組討論 分組討論後進行報告 我們這組寫下敏捷思維的核心概念，並舉出自己使用敏捷思維的例子。另外一組將敏捷寫在中間，並舉了三大特點下去延伸，呈現的方式類似心智圖，是很有組織的表示方式，可以學習。 桌遊 角色: 建築師: 只能比手畫腳 監工: 只能動口 工人: 戴上眼罩，動手組合積木 旁觀者: 什麼都不能做，只能用眼睛看 建築師抽取卡片，比出要組合積木的樣子與方向，給監工看。監工依照建築師的比劃，用說的方式指揮工人，應該要拿取哪一塊積木，並引導正確的角度，將積木放在正確的位子，以組合出卡片上所要求的樣子。 回顧(Retro) 將今天面試印象最深刻的事或任何想分享的事物寫在便利貼上，幾分鐘後進行口頭分享。 有沒有想要感謝的夥伴，覺得哪一位夥伴最不錯，為什麼? 寫回饋表單。","link":"/2020/11/26/interview-Taitan/"},{"title":"物件導向的三大特性和抽象化","text":"三大特性1. 封裝 (Encapsulation)將attribute(variable)與method打包成一個class，以隱藏實作細節，提高資料完整性。其他的class只能透過method(setter/getter)修改/取得variable的值。 private variable public method 2. 繼承 (Inheritance) 父類別(superclass) 子類別(subclass) subclass inherit superclass 將多個相同性質的子類別，擷取出共有的特徵，並將這些共有特徵定義成一個父類別，讓子類別可以繼承。避免subclass重複定義相同的attribute與method。 12345678910111213141516171819public class Animal &#123; String name; int age; Animal (String name, int age) &#123; this.name = name; this.age = age; &#125; public void eat (String food) &#123; System.out.println(\"I want to eat \" + food); &#125;&#125; public class Dog extends Animal &#123; Dog (String name, int age) &#123; super(name, age); &#125; public void eat () &#123; super.eat(\"Bones!\"); &#125;&#125; 覆寫 (overriding) 方法名稱，回傳型態，參數必須相同。 subclass的方法 覆寫 superclass的方法。 subclass可以針對其特定需求覆寫superclass的方法，讓設計更為彈性。 Dog.eat override Animal.eat12345678910public class Animal &#123; public void eat () &#123; System.out.println(\"I am not hungry!\"); &#125;&#125; public class Dog extends Animal &#123; public void eat () &#123; System.out.println(\"Bones!\"); &#125;&#125; 過載 (overloading)在同一個class裡，定義了相同名稱但是結構不同的方法。例如: 回傳型態不同，參數不同。12345678public class Animal &#123; public void eat () &#123; System.out.println(\"I am not hungry!\"); &#125; public void eat (String food) &#123; System.out.println(\"I want to eat \" + food); &#125;&#125; 3. 多型 (Polymorphism)同一個方法，有不同的行為。 override interface 123456789101112131415Interface Animal &#123; public void eat(); public void move(); public void sound();&#125;class Dog implements Animal &#123; public void eat() &#123; System.out.println(\"Bones!\"); &#125;&#125;class Cat implements Animal &#123; public void eat() &#123; System.out.println(\"Fish!\"); &#125;&#125; Abstraction (抽象化)隱藏實作細節，只提供可用功能給使用者。 Abstract Class 有abstract method 的 class 即為 Abstract class。也可以包含有body實作的concrete method。 不能夠create(new)，必須被子類別繼承後才能透過子類別create。 abstract method: 沒有body的method。必須透過子類別加以實作行為。 123456abstract class Animal &#123; public void sound(); // abstract method public void eat () &#123; // concrete method System.out.println(\"I am not hungry!\"); &#125;&#125; Interface 集結相關的abstract method。 只有abstract method。12345Interface Animal &#123; public void eat(); public void move(); public void sound();&#125;","link":"/2020/12/09/oo-basic/"},{"title":"物件導向的五大原則","text":"SOLID 原則1. SRP (Single Responsibility Principle) 一個class只對一種role(actor)負責。 以電子支付為例，使用者可以收付款項。建立一個User class，包含收錢與付錢兩個方法。12345678class User &#123; public void receive()&#123; System.out.println(\"收錢\"); &#125; public void pay()&#123; System.out.println(\"付錢\"); &#125; &#125; 當userA要付錢給userB，我們可能會這麼寫123456public static void main (string[] args) &#123; User userA = new User(); User userB = new User(); userA.pay(); userB.receive();&#125; 在作者Finn-SRP這篇文章中提到: 如果兩個方法的連動永遠都是同時變化，那就不必分離，否則可能造成不必要的複雜性。 提醒我們需避免過度優化，將功能切割的過於細小，而使程式過於複雜。 上面的程式似乎符合同時的連動與變化，還算容易理解與維護，但功能增加或需要修改時，可能就不太理想了。我們試著增加一些功能: 收款方，顯示QRcode，付款方掃描並驗證其QRcode後，輸入支付金額。收款方確認支付金額無誤後，才完成交易。並且雙方在交易完成後都能有現金5%的回饋。123456789101112131415161718192021class User &#123; public void receive()&#123; this.showQRcode(); this.verifyInputMoney(); this.cashBonus(); &#125; public void showQRcode()&#123;...&#125;; public void verifyInputMoney()&#123;...&#125; public void pay()&#123; this.openCamera(); this.verifyQRcode(); int money = scanner.NextInt(); this.cashBonus(); &#125; public void openCamera()&#123;...&#125;; public void verifyQRcode()&#123;...&#125;; public void cashBonus() &#123; balance = balance + money*5%; &#125;&#125; 若今天將政策改成付款方享有10%的現金回饋，而收款方現金回饋5%保持不變，問題就浮現了。 User class中的方法，同時對兩個actor負責。一個是付款方(payer)，另一個是收款方(payee)。因此建立兩個新的class，並將method切割出來，以實現RSP原則(一個class只對一個actor負責)。也能避免日後需求改變，修改方法(cashBonus)時，更動到其他角色應該有的正確行為。RSP原則，提高class的cohesion，使其易於維護與修改。 12345678910111213141516171819202122232425class Payee&#123; // 收款方 public void receive()&#123; this.showQRcode(); this.verifyInputMoney(); System.out.println(\"收錢\"); &#125; public void showQRcode()&#123;...&#125;; public void verifyInputMoney()&#123;...&#125; public void cashBonus() &#123; balance = balance + money*5%; &#125;&#125;class Payer&#123; // 付款方 public void pay()&#123; this.openCamera(); this.verifyQRcode(); int money = scanner.NextInt(); System.out.println(\"付錢\"); &#125; public void openCamera()&#123;...&#125;; public void verifyQRcode()&#123;...&#125;; public void cashBonus() &#123; balance = balance + money*10%; &#125;&#125; 2. OCP (Open-Closed Principle)在設計已經完整的前提下，修改程式的兩個主要原因為: 增加新功能 修正問題(bugs) 若修改程式是為了增加新功能，就必須符合OCP原則。 Open for extension 開放擴充 Closed for modification 避免修改 達成OCP的方式: Abstract class Interface Decorator Strategy DIP 3. LSP (Liskov Substitution Priniple) Subtypes must be substitutable for their base types. 所有的subclass必須能夠在不破壞/不修改程式的情況下，使用parent class中的所有方法。 在實作OCP的同時，必須符合LSP。以下為違反LSP的例子:以哺乳類為例，除少數哺乳類，例如:鴨嘴獸(platypus)是卵生，其餘皆為胎生。123456class Mammal &#123; public void giveBirth(); // 直接生下胎兒&#125;class Platypus extends Mammal &#123; public void layegg(); // 產卵&#125; class Platypus 無法使用class Mammal中的giveBirth method ，違反LSP原則。 extends 為 IS-A 的關係Platypus cannot giveBirth. Thus, Platypus is not a Mammal, Platypus cannot extend Mammal. 透過Design by Contract來避免違反LSP: preconditions postconditions class invariants Subclasses need to follow these rules: Don’t implement any stricter validation rules on input parameters than implemented by the parent class.父類別的條件要比子類別嚴格 Apply at the least the same rules to all output parameters as applied by the parent class. 4. ISP (Interface Segregation Principle) Clients should not be forced to depend upon interfaces that they do not use. 以遙控器為例:電視遙控器可以開，關，預錄節目。冷氣遙控器可以開，關，設定溫度。可以發現電視遙控器並不需要設定溫度的功能，冷氣遙控器並不需要預錄節目的功能。123456interface RemoteControl &#123; public void on(); public void off(); public void set(); public void record();&#125; 為了預防 Bloated Interface，透過ISP原則，將Interface進行切割。我們建立兩個新的Interface，TVRemote與AirConditionerRemote，將電視與冷氣個別會用到的功能切割出去。interface RemoteControl則保留最基本的遙控器開關功能。123456789101112interface TVRemote &#123; public void setChannel(); public void record();&#125;interface AirConditionerRemote &#123; public void setTemperature(); public void setTime();&#125;interface RemoteControl &#123; public void on(); public void off();&#125; ISP與SRP相似，主張Class或Interface不應該包含多種用不到的或不相關的責任。避免需求改變時，因程式修改所產生的負面影響。因此將Class或Interface切割，雖然Class或Interface的數量增加，但cohesion提高。兩者之間的差異: ISP避免Interface包含了client用不到的method SRP避免一個Class負責不同的角色 5. DIP (Dependency Inversion Principle) High-level modules should not depend on low-level modules. Both should depend on abstractions.Abstractions should not depend on details. Details should depend on abstractions. 切割兩個Class之間的依賴關係，建立一個新的抽象介面(Abstraction)，讓Class更容易擴充(OCP)，同時也必須遵守(LSP)。只要持續且正確的應用OCP與LSP，將會符合DIP。splits the dependency between the high-level and low-level modules by introducing an abstraction between them. So in the end, there are two dependencies: the high-level module depends on the abstraction, and the low-level depends on the same abstraction. 以Airplane為例，飛機可以在跑道上跑(run)，也可以飛到空中(fly)。Jet依賴於Airplane的run和fly功能，並且可以射擊(shoot)與防禦(defend)。123456789101112131415class Airplane &#123; public void run () &#123;...&#125; public void fly () &#123;...&#125;&#125;class Jet &#123; private Airplane airplane public void run () &#123; airplane.run(); &#125; public void fly () &#123; airplane.fly(); &#125; public void shoot () &#123;...&#125; public void defend () &#123;...&#125;&#125; 為了降低coupling(減少class之間的依賴關係)，並讓功能容易擴充避免修改(OCP)，建立Interface AirplaneAction，讓Airplane和Jet可以實作run和fly。由於Airplane並不能shoot和defend，因此新增一個軍備的Interface Arms，讓Jet實作shoot和defend，以遵守LSP。 參考資料SRPOCPLSPISPDIP","link":"/2020/12/10/oo-principle/"},{"title":"遞迴與迴圈","text":"遞迴 Recursion以求N的階乘為例fac(1) = 1fac(N) = N * fac(N-1) 內涵式遞迴 Embedded recursion 最後一個函式fac(1)呼叫完成後，一層層由內而外回傳數值並計算。 階層式架構 123456public int fac(int n) &#123; if (n == 1) // 設定終止條件 return 1; else return n * fac(n-1); // 控制變數 n，使其接近終止值&#125; fac(3)return 3 * fac(3-1) // n=3return 3 * 2 * fac(2-1) // n=2return 3 * 2 * 1 * fac(1) // n=1 尾端式遞迴 Tail recursion 增加一個參數(ans)，紀錄累乘值。 平的架構 123456public int fac(int n, int ans) &#123; if (n == 0) //設定終止條件 return ans; else return fac(n-1, ans*n); // 控制變數 n，使其接近終止值&#125; fac(3, 1)return fac(2, 1*3)return fac(1, 3*2)return fac(0, 6*1) 可以將尾端式遞迴轉換成While迴圈 迴圈 Loop 將尾端式遞迴的終止條件，以not的形式當作while的進行條件。 將參數的變動放在迴圈中，必須先累乘，才將n-1。 12345678public int fac(int n) &#123; int ans = 1; while (n != 0) &#123; // 設定進行條件 ans = ans * n; n--; // 控制變數 n，使迴圈得以停止 &#125; return ans;&#125;","link":"/2020/12/11/recursion/"},{"title":"weatherMap","text":"A Taiwan weather map create by Vue.js. demo https://s.codepen.io/becomegood0308/debug/GbyNVM/NjMYzqbKOjDr codepen: https://codepen.io/becomegood0308/pen/GbyNVM svg name and get id/data-name data regular expressions json data array Vue.js / jQuery vobj = vm vm.filter = &lt;p id=&quot;&quot;&gt; 參考資料https://www.youtube.com/watch?v=eHrGB5EHtF4","link":"/2019/06/29/weatherMap/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"internship","slug":"internship","link":"/tags/internship/"},{"name":"reflection","slug":"reflection","link":"/tags/reflection/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"OOSE","slug":"OOSE","link":"/tags/OOSE/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"json","slug":"json","link":"/tags/json/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Front-end","slug":"Notes/Front-end","link":"/categories/Notes/Front-end/"},{"name":"Reflection","slug":"Reflection","link":"/categories/Reflection/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"}]}